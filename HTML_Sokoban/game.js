// game.js - 推箱子游戏主文件

// 多语言支持
let currentLanguage = 'zh'; // 默认中文

// 建造模式功能函数
let cancelBuildMode = null;
let confirmBuildLevel = null;

// 多语言字典
const languageDict = {
    zh: {
        title: "AI生成推箱子关卡",
        loading: "正在加载游戏资源...",
        resetBtn: "重置关卡",
        newLevelBtn: "新关卡",
        undoBtn: "撤销",
        aiDemoBtn: "AI求解",
        saveLevelBtn: "存储关卡",
        loadLevelBtn: "加载关卡",
        buildLevelBtn: "搭建关卡",
        pauseBtn: "暂停演示",
        resumeBtn: "继续演示",
        instruction1: "使用方向键或WASD键移动玩家，将所有箱子推到目标点上即可完成关卡。",
        instruction2: "按Z键或回退键可以撤销上一步。",
        instruction3: "关卡由AI算法自动生成，保证有解且具有一定难度。",
        ai: "AI",
        generateProgress: "正在AI生成关卡: {progress}% (迭代 {iteration}/{maxTries})",
        aiLevelInfo: "AI关卡信息: 箱子最少推动次数 {minSteps}, 生成迭代次数 {iterations}, 墙壁数量 {wallCount}",
        generateTimeout: "关卡生成超时！使用备用方法",
        boxPushes: "当前已推动箱子次数：{count}",
        winMessage: "恭喜！你完成了当前关卡，共移动 {moves} 步，推动箱子 {pushes} 次！",
        optimalSolution: "你已达到最优解！",
        notOptimalSolution: "但你不是最优解（最少推动次数为{minSteps}），是否重新体验本关？",
        confirmReplay: "选择你的下一步操作：",
        replayBtn: "重来",
        newLevelBtn: "新关卡",
        aiFailed: "AI无法找到解决方案，请尝试其他关卡。",
        aiError: "AI演示过程出错，请重试。",
        settingsTitle: "游戏设置",
        boardSize: "关卡尺寸",
        boardSizeDesc: "设置关卡的宽度和高度（6×6到11×11）",
        aiParams: "AI生成参数",
        maxTries: "最大生成迭代次数",
        maxTriesDesc: "设置AI生成关卡的最大尝试次数（10-500），越大生成的关卡平均来说可能更难",
        maxIterations: "求解器最大迭代次数",
        maxIterationsDesc: "设置求解器的最大迭代次数（5000-200000），更高值可解决更复杂关卡但耗时更长",
        maxNodes: "求解器最大内存节点数",
        maxNodesDesc: "设置求解器的最大内存节点数（10000-500000），更高值允许更深搜索但占用更多内存",
        wallProb: "墙壁生成概率",
        wallProbDesc: "设置生成墙壁的概率（0.1-0.7），越高关卡越复杂",
        boxProb: "箱子生成概率",
        boxProbDesc: "设置生成箱子和目标点的概率（0.1-0.5），影响关卡平衡性",
        resetDefault: "重置默认",
        save: "保存",
        settingsSaved: "设置已保存，生成新关卡时将应用新设置",
        sizeChanged: "关卡尺寸已修改，正在生成新关卡...",
        confirmReset: "确定要将所有设置恢复为默认值吗？",
        settingsReset: "设置已重置为默认值，正在生成新关卡...",
        recommendedApplied: "✅ 已应用推荐设置！这些参数经过测试优化，能提供良好的游戏体验。",
        jsError: "js目录不存在，请确保创建了js目录并包含所有模块文件",
        scriptError: "游戏脚本加载失败！请检查网络连接并刷新页面。",
        aiStepProgress: "AI演示：步骤 {current}/{total}",
        aiComplete: "AI成功完成了关卡，共移动 {steps} 步，推动箱子 {pushes} 次！",
        aiReplay: "是否要重新体验当前关卡？",
        unknownValue: "未知",
        levelSaved: "关卡保存成功！",
        saveLevelSuccess: "关卡已成功保存！",
        saveLevelFail: "关卡保存失败，请重试。",
        loadLevelSuccess: "关卡已成功加载！",
        loadLevelFail: "关卡加载失败，请确保已保存关卡。",
        noSavedLevel: "没有找到已保存的关卡。",
        buildLevelTitle: "人工搭建关卡",
        buildLevelInstructions: "点击选择物品，然后点击游戏区域放置。",
        buildLevelComplete: "关卡搭建完成",
        buildLevelCancel: "取消",
        buildLevelPlayer: "玩家",
        buildLevelWall: "墙壁",
        buildLevelBox: "箱子",
        buildLevelTarget: "目标点",
        buildLevelFloor: "地板",
        buildLevelConfirm: "保存并开始",
        buildLevelValidating: "验证关卡有效性...",
        buildLevelInvalid: "关卡无效，请确保有一个玩家、至少一个箱子和相同数量的目标点，并且确保所有箱子都能到达所有目标点。",
        buildLevelSuccess: "关卡已成功搭建！您可以开始游戏了。",
        settingsBtn: "设置",
        clearSceneBtn: "清空场景",
        validateLevelBtn: "验证关卡",
        levelValid: "关卡有解！最少推箱子步数: {minSteps}",
        levelInvalid: "当前配置下关卡可能无解",
        levelValidating: "正在验证关卡...",
        sceneCleared: "场景已清空",
        confirmClearScene: "确定要清空当前场景吗？",
        cancel: "取消",
        confirm: "确定"
    },
    en: {
        title: "AI Generated Sokoban Levels",
        loading: "Loading game resources...",
        resetBtn: "Reset Level",
        newLevelBtn: "New Level",
        undoBtn: "Undo",
        aiDemoBtn: "AI Solve",
        saveLevelBtn: "Save Level",
        loadLevelBtn: "Load Level",
        buildLevelBtn: "Build Level",
        pauseBtn: "Pause Demo",
        resumeBtn: "Resume Demo",
        instruction1: "Use arrow keys or WASD to move the player, push all boxes to target points to complete the level.",
        instruction2: "Press Z or Backspace to undo the last move.",
        instruction3: "Levels are generated by AI algorithm, guaranteed to be solvable and challenging.",
        ai: "AI",
        generateProgress: "AI generating level: {progress}% (Iteration {iteration}/{maxTries})",
        aiLevelInfo: "AI Level Info: Min box pushes {minSteps}, Generation iterations {iterations}, Wall count {wallCount}",
        generateTimeout: "Level generation timeout! Using fallback method",
        boxPushes: "Current box pushes: {count}",
        winMessage: "Congratulations! You completed the level with {moves} moves and {pushes} box pushes!",
        optimalSolution: "You've reached the optimal solution!",
        notOptimalSolution: "But you didn't reach the optimal solution (min pushes: {minSteps}). Try again?",
        confirmReplay: "Choose your next action:",
        replayBtn: "Replay",
        newLevelBtn: "New Level",
        aiFailed: "AI couldn't find a solution, please try another level.",
        aiError: "AI demonstration error, please try again.",
        settingsTitle: "Game Settings",
        boardSize: "Board Size",
        boardSizeDesc: "Set the width and height of the level (6×6 to 11×11)",
        aiParams: "AI Generation Parameters",
        maxTries: "Maximum Generation Iterations",
        maxTriesDesc: "Set the maximum number of AI level generation attempts (10-500), higher values may generate more difficult levels",
        maxIterations: "Solver Maximum Iterations",
        maxIterationsDesc: "Set the maximum iterations for the solver (5000-200000), higher values can solve more complex levels but take longer",
        maxNodes: "Solver Maximum Memory Nodes",
        maxNodesDesc: "Set the maximum memory nodes for the solver (10000-500000), higher values allow deeper search but use more memory",
        wallProb: "Wall Generation Probability",
        wallProbDesc: "Set the probability of generating walls (0.1-0.7), higher values create more complex levels",
        boxProb: "Box Generation Probability",
        boxProbDesc: "Set the probability of generating boxes and targets (0.1-0.5), affects level balance",
        resetDefault: "Reset Defaults",
        save: "Save",
        settingsSaved: "Settings saved, they will be applied when generating new levels",
        sizeChanged: "Board size changed, generating a new level...",
        confirmReset: "Are you sure you want to reset all settings to default values?",
        settingsReset: "Settings have been reset to default values, generating a new level...",
        recommendedApplied: "✅ Recommended settings applied! These parameters are optimized for the best gaming experience.",
        jsError: "js directory doesn't exist, please ensure you've created the js directory and included all module files",
        scriptError: "Game script loading failed! Please check your network connection and refresh the page.",
        aiStepProgress: "AI Demo: Step {current}/{total}",
        aiComplete: "AI successfully completed the level with {steps} moves and {pushes} box pushes!",
        aiReplay: "Would you like to replay this level?",
        unknownValue: "Unknown",
        levelSaved: "Level saved successfully!",
        saveLevelSuccess: "Level has been saved successfully!",
        saveLevelFail: "Failed to save level, please try again.",
        loadLevelSuccess: "Level has been loaded successfully!",
        loadLevelFail: "Failed to load level, please make sure you have saved a level.",
        noSavedLevel: "No saved level found.",
        buildLevelTitle: "Build Your Own Level",
        buildLevelInstructions: "Click to select an item, then click on the game area to place it.",
        buildLevelComplete: "Level Building Complete",
        buildLevelCancel: "Cancel",
        buildLevelPlayer: "Player",
        buildLevelWall: "Wall",
        buildLevelBox: "Box",
        buildLevelTarget: "Target",
        buildLevelFloor: "Floor",
        buildLevelConfirm: "Confirm & Start",
        buildLevelValidating: "Validating level...",
        buildLevelInvalid: "Invalid level. Please ensure there is one player, at least one box and the same number of targets, and make sure all boxes can reach all targets.",
        buildLevelSuccess: "Level has been built successfully! You can start playing now.",
        settingsBtn: "Settings",
        clearSceneBtn: "Clear Scene",
        validateLevelBtn: "Validate Level",
        levelValid: "Level is solvable! Minimum box pushes: {minSteps}",
        levelInvalid: "Level may be unsolvable with current configuration",
        levelValidating: "Validating level...",
        sceneCleared: "Scene cleared",
        confirmClearScene: "Are you sure you want to clear the current scene?",
        cancel: "Cancel",
        confirm: "Confirm"
    }
};

// 获取翻译文本
function getText(key, params = {}) {
    const text = languageDict[currentLanguage][key] || key;

    // 替换参数
    return text.replace(/\{(\w+)\}/g, (match, paramName) => {
        return params[paramName] !== undefined ? params[paramName] : match;
    });
}

// 通用自定义弹窗系统
function createCustomDialog(options) {
    const {
        message,
        type = 'alert', // 'alert', 'confirm', 'custom'
        buttons = [],
        onClose = null,
        allowBackgroundClose = true,
        allowEscClose = true
    } = options;

    // 创建模态框背景
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 2000;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: Arial, sans-serif;
    `;

    // 创建对话框内容
    const dialog = document.createElement('div');
    dialog.style.cssText = `
        background-color: #fff;
        border-radius: 12px;
        padding: 24px;
        max-width: 400px;
        width: 90%;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        text-align: center;
        animation: slideIn 0.3s ease-out;
    `;

    // 添加动画样式（如果还没有）
    if (!document.getElementById('custom-dialog-styles')) {
        const style = document.createElement('style');
        style.id = 'custom-dialog-styles';
        style.textContent = `
            @keyframes slideIn {
                from {
                    opacity: 0;
                    transform: scale(0.8) translateY(-20px);
                }
                to {
                    opacity: 1;
                    transform: scale(1) translateY(0);
                }
            }
        `;
        document.head.appendChild(style);
    }

    // 创建消息文本
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        margin-bottom: 24px;
        font-size: 16px;
        line-height: 1.5;
        color: #333;
        white-space: pre-line;
    `;
    messageDiv.textContent = message;

    // 创建按钮容器
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
    `;

    // 关闭对话框的函数
    const closeDialog = (result = null) => {
        if (modal.parentNode) {
            document.body.removeChild(modal);
        }
        if (onClose) onClose(result);
    };

    // 根据类型创建按钮
    let dialogButtons = [];

    if (type === 'alert') {
        dialogButtons = [{
            text: '确定',
            style: 'primary',
            action: () => closeDialog(true)
        }];
    } else if (type === 'confirm') {
        dialogButtons = [
            {
                text: '取消',
                style: 'secondary',
                action: () => closeDialog(false)
            },
            {
                text: '确定',
                style: 'primary',
                action: () => closeDialog(true)
            }
        ];
    } else if (type === 'custom' && buttons.length > 0) {
        dialogButtons = buttons;
    }

    // 创建按钮
    dialogButtons.forEach((buttonConfig, index) => {
        const button = document.createElement('button');
        button.textContent = buttonConfig.text;

        // 设置按钮样式
        const isPrimary = buttonConfig.style === 'primary';
        const isSecondary = buttonConfig.style === 'secondary';

        let backgroundColor = '#6c757d'; // 默认灰色
        let hoverColor = '#5a6268';

        if (isPrimary) {
            backgroundColor = '#4CAF50'; // 绿色
            hoverColor = '#45a049';
        } else if (isSecondary) {
            backgroundColor = '#f44336'; // 红色
            hoverColor = '#d32f2f';
        } else if (buttonConfig.color) {
            backgroundColor = buttonConfig.color;
            hoverColor = buttonConfig.hoverColor || buttonConfig.color;
        }

        button.style.cssText = `
            background-color: ${backgroundColor};
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            min-width: 120px;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        `;

        // 添加悬停效果
        button.addEventListener('mouseenter', () => {
            button.style.backgroundColor = hoverColor;
            button.style.transform = 'translateY(-1px)';
        });

        button.addEventListener('mouseleave', () => {
            button.style.backgroundColor = backgroundColor;
            button.style.transform = 'translateY(0)';
        });

        // 添加点击事件
        button.addEventListener('click', () => {
            if (buttonConfig.action) {
                // 先关闭对话框，再执行action
                closeDialog(index);
                buttonConfig.action();
            } else {
                closeDialog(index);
            }
        });

        buttonContainer.appendChild(button);
    });

    // 组装对话框
    dialog.appendChild(messageDiv);
    dialog.appendChild(buttonContainer);
    modal.appendChild(dialog);

    // 添加到页面
    document.body.appendChild(modal);

    // 点击背景关闭
    if (allowBackgroundClose) {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeDialog(false);
            }
        });
    }

    // ESC键关闭
    if (allowEscClose) {
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                document.removeEventListener('keydown', escHandler);
                closeDialog(false);
            }
        };
        document.addEventListener('keydown', escHandler);
    }

    return modal;
}

// 自定义Alert弹窗
function showCustomAlert(message, onClose = null) {
    return createCustomDialog({
        message: message,
        type: 'alert',
        onClose: onClose
    });
}

// 自定义Confirm弹窗
function showCustomConfirm(message, onConfirm = null, onCancel = null) {
    // 兼容原有的双参数调用方式（用于游戏胜利对话框）
    if (typeof onConfirm === 'function' && typeof onCancel === 'function') {
        return createCustomDialog({
            message: message,
            type: 'custom',
            buttons: [
                {
                    text: getText('replayBtn'),
                    style: 'primary',
                    color: '#4CAF50',
                    hoverColor: '#45a049',
                    action: onConfirm
                },
                {
                    text: getText('newLevelBtn'),
                    style: 'secondary',
                    color: '#2196F3',
                    hoverColor: '#1976D2',
                    action: onCancel
                }
            ],
            allowBackgroundClose: true,
            allowEscClose: true,
            onClose: (result) => {
                if (result === false && onCancel) onCancel();
            }
        });
    }

    // 标准的confirm调用方式
    return createCustomDialog({
        message: message,
        type: 'confirm',
        onClose: (result) => {
            if (result && onConfirm) {
                onConfirm();
            } else if (!result && onCancel) {
                onCancel();
            }
        }
    });
}

// 专门用于建造模式的确认对话框
function showBuildModeConfirm(message, onConfirm = null, onCancel = null) {
    return createCustomDialog({
        message: message,
        type: 'custom',
        buttons: [
            {
                text: getText('cancel') || '取消',
                style: 'secondary',
                color: '#6c757d',
                hoverColor: '#5a6268',
                action: onCancel
            },
            {
                text: getText('confirm') || '确定',
                style: 'primary',
                color: '#007bff',
                hoverColor: '#0056b3',
                action: onConfirm
            }
        ],
        allowBackgroundClose: true,
        allowEscClose: true,
        onClose: (result) => {
            if (result === false && onCancel) onCancel();
        }
    });
}

// 切换语言功能
window.toggleLanguage = function () {
    currentLanguage = currentLanguage === 'zh' ? 'en' : 'zh';

    // 保存语言设置到本地存储
    try {
        localStorage.setItem('sokobanLanguage', currentLanguage);
    } catch (e) {
        console.warn("无法保存语言设置:", e);
    }

    // 更新页面上的文本
    updatePageText();
};

// 更新页面上的所有文本
function updatePageText() {
    // 更新标题
    document.title = getText('title');
    document.querySelector('h1').textContent = getText('title');

    // 更新加载信息
    const loadingMsg = document.getElementById('loading-message');
    if (loadingMsg && loadingMsg.style.display !== 'none') {
        loadingMsg.textContent = getText('loading');
    }

    // 更新按钮文本
    document.getElementById('reset-btn').textContent = getText('resetBtn');
    document.getElementById('new-level-btn').textContent = getText('newLevelBtn');
    document.getElementById('undo-btn').textContent = getText('undoBtn');
    document.getElementById('save-level-btn').textContent = getText('saveLevelBtn');
    document.getElementById('load-level-btn').textContent = getText('loadLevelBtn');
    document.getElementById('build-level-btn').textContent = getText('buildLevelBtn');

    // 更新设置按钮文本
    const settingsBtn = document.getElementById('settings-btn');
    if (settingsBtn) {
        settingsBtn.textContent = getText('settingsBtn');
    }

    const aiDemoBtn = document.getElementById('ai-demo-btn');
    if (aiDemoBtn) {
        if (aiDemoInProgress && !aiDemoPaused) {
            aiDemoBtn.textContent = getText('pauseBtn');
        } else if (aiDemoInProgress && aiDemoPaused) {
            aiDemoBtn.textContent = getText('resumeBtn');
        } else {
            aiDemoBtn.textContent = getText('aiDemoBtn');
        }
    }

    // 更新说明文本
    const instructions = document.querySelectorAll('.instructions p');
    if (instructions.length >= 3) {
        instructions[0].textContent = getText('instruction1');
        instructions[1].textContent = getText('instruction2');
        instructions[2].innerHTML = `<span class="ai-badge">${getText('ai')}</span> ${getText('instruction3')}`;
    }

    // 更新AI信息
    updateAIInfoText();

    // 更新推箱子次数显示
    updatePushCountDisplay();

    // 更新设置模态框
    updateSettingsModal();

    // 更新建造模式面板（如果存在）
    updateBuildModeUI();
}

// 更新AI信息文本
function updateAIInfoText() {
    const aiInfo = document.getElementById('ai-info');
    if (aiInfo && aiInfo.textContent) {
        // 从现有文本中提取数值
        const minStepsMatch = aiInfo.textContent.match(/箱子最少推动次数\s+(\d+)/i) ||
            aiInfo.textContent.match(/Min box pushes\s+(\d+)/i);
        const iterationsMatch = aiInfo.textContent.match(/生成迭代次数\s+(\d+)/i) ||
            aiInfo.textContent.match(/Generation iterations\s+(\d+)/i);
        const wallCountMatch = aiInfo.textContent.match(/墙壁数量\s+(\d+|未知|Unknown)/i) ||
            aiInfo.textContent.match(/Wall count\s+(\d+|未知|Unknown)/i);

        if (minStepsMatch && iterationsMatch) {
            const minSteps = minStepsMatch[1];
            const iterations = iterationsMatch[1];
            const wallCount = wallCountMatch ? (wallCountMatch[1] === '未知' || wallCountMatch[1] === 'Unknown' ?
                getText('unknownValue') : wallCountMatch[1]) : getText('unknownValue');

            aiInfo.textContent = getText('aiLevelInfo', {
                minSteps: minSteps,
                iterations: iterations,
                wallCount: wallCount
            });
        }
    }
}

// 更新设置模态框文本
function updateSettingsModal() {
    // 标题
    const settingsTitle = document.querySelector('#settings-modal .modal-header h2');
    if (settingsTitle) {
        settingsTitle.textContent = getText('settingsTitle');
    }

    // 设置选项标签
    const settingLabels = document.querySelectorAll('#settings-modal .setting-label');
    if (settingLabels.length > 0) {
        // 寻找主要标签
        for (const label of settingLabels) {
            if (label.textContent.includes('关卡尺寸') || label.textContent.includes('Board Size')) {
                label.textContent = getText('boardSize');
            } else if (label.textContent.includes('AI生成参数') || label.textContent.includes('AI Generation Parameters')) {
                label.textContent = getText('aiParams');
            } else if (label.textContent.includes('最大生成迭代次数') || label.textContent.includes('Maximum Generation Iterations')) {
                label.textContent = getText('maxTries');
            } else if (label.textContent.includes('求解器最大迭代次数') || label.textContent.includes('Solver Maximum Iterations')) {
                label.textContent = getText('maxIterations');
            } else if (label.textContent.includes('求解器最大内存节点数') || label.textContent.includes('Solver Maximum Memory Nodes')) {
                label.textContent = getText('maxNodes');
            } else if (label.textContent.includes('墙壁生成概率') || label.textContent.includes('Wall Generation Probability')) {
                label.textContent = getText('wallProb');
            } else if (label.textContent.includes('箱子生成概率') || label.textContent.includes('Box Generation Probability')) {
                label.textContent = getText('boxProb');
            }
        }
    }

    // 设置描述
    const settingDescs = document.querySelectorAll('#settings-modal .setting-description');
    if (settingDescs.length > 0) {
        const descTexts = [
            'boardSizeDesc', 'maxTriesDesc', 'maxIterationsDesc',
            'maxNodesDesc', 'wallProbDesc', 'boxProbDesc'
        ];

        for (let i = 0; i < Math.min(settingDescs.length, descTexts.length); i++) {
            settingDescs[i].textContent = getText(descTexts[i]);
        }
    }

    // 按钮
    const resetBtn = document.querySelector('#settings-modal .btn-reset');
    if (resetBtn) {
        resetBtn.textContent = getText('resetDefault');
    }

    const saveBtn = document.querySelector('#settings-modal .btn-save');
    if (saveBtn) {
        saveBtn.textContent = getText('save');
    }
}

// 游戏配置
const config = {
    boardSize: { width: 10, height: 10 },
    numBoxes: 3,
    numWalls: 20,
    tileSize: 40, // 每个格子大小单位：像素，例如347
    canvasWidth: 0,  // 将在初始化时设置
    canvasHeight: 0,  // 将在初始化时设置
    useAIGeneration: true, // 是否使用AI生成关卡
    aiGenerationMaxTries: 100, // 适当减少AI生成关卡最大尝试次数，原来是100
    aiTimeout: 8000 // AI生成超时时间（毫秒）
};

// 默认设置，用于重置
const defaultSettings = {
    boardSize: { width: 10, height: 10 },
    aiGenerationMaxTries: 100,
    maxSolverIterations: 15000,  // 1.5万次迭代 (AI生成验证用)
    maxNodesInMemory: 30000,     // 3万内存节点 (AI生成验证用)
    aiTimeout: 12000,            // AI生成超时时间
    wallProbability: 0.4,
    boxProbability: 0.2
};

// 游戏状态
let gameState = {
    board: [],
    playerPos: { x: 0, y: 0 },
    boxes: [],
    targets: [],
    moves: 0,
    boxPushes: 0,  // 添加箱子推动次数统计
    playerDirection: 'd',  // 玩家朝向：u(上)、d(下)、l(左)、r(右)
    isMoving: false,       // 是否正在移动
    animationFrame: 0,     // 当前动画帧 (0,1,2对应帧00,01,02)
    animationStep: 0,      // 移动步骤 (0,1,2)
    startPos: { x: 0, y: 0 },  // 移动起始点
    targetPos: { x: 0, y: 0 },   // 移动目标点
    moveHistory: [],       // 移动历史记录，用于撤销功能
    generatingLevel: false, // 是否正在生成关卡
    minSolutionSteps: 0    // 最少解决步骤数
};

// 当前关卡迭代次数
let currentLevelIterations = 1;

// 保存初始关卡状态以便重置
let initialLevelState = {
    board: [],
    playerPos: { x: 0, y: 0 },
    boxes: [],
    targets: []
};

// 深拷贝对象函数
function deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
}

// Canvas和上下文
let canvas, ctx;

// AI关卡生成器导入
let AILevelGenerator;

// 初始化游戏板
function initializeBoard() {
    gameState.board = Array(config.boardSize.height).fill().map(() =>
        Array(config.boardSize.width).fill('floor'));

    // 添加边界墙
    for (let i = 0; i < config.boardSize.height; i++) {
        gameState.board[i][0] = 'wall';
        gameState.board[i][config.boardSize.width - 1] = 'wall';
    }
    for (let j = 0; j < config.boardSize.width; j++) {
        gameState.board[0][j] = 'wall';
        gameState.board[config.boardSize.height - 1][j] = 'wall';
    }
}

// 随机生成位置
function getRandomPosition() {
    return {
        x: Math.floor(Math.random() * (config.boardSize.width - 2)) + 1,
        y: Math.floor(Math.random() * (config.boardSize.height - 2)) + 1
    };
}

// 检查位置是否为空
function isPositionEmpty(pos) {
    return gameState.board[pos.y][pos.x] === 'floor' &&
        !gameState.boxes.some(box => box.x === pos.x && box.y === pos.y) &&
        !(gameState.playerPos.x === pos.x && gameState.playerPos.y === pos.y);
}

// 更新生成进度UI
function updateGenerationProgress(progress) {
    const loadingMsg = document.getElementById('loading-message');
    if (loadingMsg) {
        loadingMsg.style.display = 'block';
        loadingMsg.textContent = getText('generateProgress', {
            progress: progress.progress,
            iteration: progress.iteration,
            maxTries: progress.maxTries
        });
    }
}

// 隐藏生成进度UI
function hideGenerationProgress() {
    const loadingMsg = document.getElementById('loading-message');
    if (loadingMsg) {
        loadingMsg.style.display = 'none';
    }
}

// 更新AI关卡生成信息
function updateAILevelInfo(minSteps, iterations, wallCount) {
    // 创建并分发自定义事件
    const event = new CustomEvent('ai-level-generated', {
        detail: {
            minSteps: minSteps,
            iterations: iterations,
            wallCount: wallCount
        }
    });
    window.dispatchEvent(event);

    // 隐藏加载信息
    hideGenerationProgress();
}

// 生成新关卡
async function generateNewLevel() {
    // 如果AI演示正在进行，先结束演示
    if (aiDemoInProgress) {
        endAiDemo();
    }

    // 防止重复生成
    if (gameState.generatingLevel) {
        return;
    }

    // 重置胜利对话框标志
    winDialogShown = false;

    gameState.boxes = [];
    gameState.targets = [];
    gameState.moves = 0;
    gameState.boxPushes = 0;  // 重置箱子推动次数
    gameState.playerDirection = 'd';
    gameState.isMoving = false;
    gameState.animationFrame = 0;
    gameState.animationStep = 0;
    gameState.moveHistory = []; // 清空移动历史
    gameState.generatingLevel = true; // 标记正在生成关卡

    // 设置生成超时
    let generationTimeout = null;
    const timeoutPromise = new Promise((resolve) => {
        generationTimeout = setTimeout(() => {
            console.warn("关卡生成超时！使用备用方法");
            resolve({ timedOut: true });
        }, config.aiTimeout);
    });

    initializeBoard();

    // 使用AI生成关卡
    if (config.useAIGeneration && AILevelGenerator) {
        try {
            updateGenerationProgress({ iteration: 0, maxTries: config.aiGenerationMaxTries, progress: 0 });

            // 创建生成器实例时传递所有参数
            const generator = new AILevelGenerator(
                config.boardSize.width,
                config.boardSize.height,
                {
                    maxSolverIterations: defaultSettings.maxSolverIterations,
                    maxNodesInMemory: defaultSettings.maxNodesInMemory,
                    maxGenerationTime: config.aiTimeout - 1000, // 给主流程留出1秒钟冗余
                    wallProbability: defaultSettings.wallProbability, // 使用默认设置中的概率值
                    boxProbability: defaultSettings.boxProbability  // 使用默认设置中的概率值
                }
            );

            // 竞争超时和正常结果
            const result = await Promise.race([
                generator.generateLevel(config.aiGenerationMaxTries, updateGenerationProgress),
                timeoutPromise
            ]);

            // 清除超时定时器
            if (generationTimeout) {
                clearTimeout(generationTimeout);
                generationTimeout = null;
            }

            if (result.timedOut) {
                // 处理超时情况
                console.warn("AI生成关卡超时，使用随机生成方法");
                generateRandomLevel();
            } else if (result.success) {
                // 使用AI生成的关卡
                gameState.board = deepCopy(result.level.board);
                gameState.playerPos = deepCopy(result.level.playerPos);
                gameState.boxes = deepCopy(result.level.boxes);
                gameState.targets = deepCopy(result.level.targets);
                gameState.minSolutionSteps = result.minSteps;

                // 显示最少步数
                console.log(`AI生成的关卡解决方案最少步数: ${result.minSteps}, 经过了${result.iterations}次迭代, 墙壁数量: ${result.wallCount}`);

                // 更新AI信息区域
                updateAILevelInfo(result.minSteps, result.iterations, result.wallCount);
            } else {
                // AI生成失败，使用随机生成
                console.error('AI生成关卡失败:', result.error);
                generateRandomLevel();
            }
        } catch (error) {
            console.error('AI生成关卡异常:', error);
            generateRandomLevel();
        } finally {
            hideGenerationProgress();
        }
    } else {
        // 使用原来的随机生成逻辑
        generateRandomLevel();
    }

    // 保存初始关卡状态
    saveInitialState();
    gameState.generatingLevel = false;

    // 渲染关卡
    renderGame();
}

// 原始的随机生成逻辑
function generateRandomLevel() {
    // 放置玩家
    let pos = getRandomPosition();
    while (!isPositionEmpty(pos)) {
        pos = getRandomPosition();
    }
    gameState.playerPos = pos;
    gameState.startPos = { ...pos };
    gameState.targetPos = { ...pos };

    // 放置箱子和目标
    for (let i = 0; i < config.numBoxes; i++) {
        // 放置箱子
        pos = getRandomPosition();
        while (!isPositionEmpty(pos)) {
            pos = getRandomPosition();
        }
        gameState.boxes.push({ ...pos });

        // 放置目标
        pos = getRandomPosition();
        while (!isPositionEmpty(pos)) {
            pos = getRandomPosition();
        }
        gameState.targets.push({ ...pos });
    }

    // 放置额外的墙
    for (let i = 0; i < config.numWalls; i++) {
        pos = getRandomPosition();
        while (!isPositionEmpty(pos)) {
            pos = getRandomPosition();
        }
        gameState.board[pos.y][pos.x] = 'wall';
    }
}

// 保存当前关卡的初始状态
function saveInitialState() {
    initialLevelState.board = deepCopy(gameState.board);
    initialLevelState.playerPos = deepCopy(gameState.playerPos);
    initialLevelState.boxes = deepCopy(gameState.boxes);
    initialLevelState.targets = deepCopy(gameState.targets);
}

// 重置当前关卡
function resetLevel() {
    // 如果AI演示正在进行，先结束演示
    if (aiDemoInProgress) {
        endAiDemo();
    }

    // 重置胜利对话框标志
    winDialogShown = false;

    // 重置移动次数和动画状态
    gameState.moves = 0;
    gameState.boxPushes = 0;  // 重置箱子推动次数
    gameState.playerDirection = 'd';
    gameState.isMoving = false;
    gameState.animationFrame = 0;
    gameState.animationStep = 0;
    gameState.moveHistory = []; // 清空移动历史

    // 从初始状态还原关卡
    gameState.board = deepCopy(initialLevelState.board);
    gameState.playerPos = deepCopy(initialLevelState.playerPos);
    gameState.boxes = deepCopy(initialLevelState.boxes);
    gameState.targets = deepCopy(initialLevelState.targets);

    // 更新起始位置和目标位置
    gameState.startPos = { ...gameState.playerPos };
    gameState.targetPos = { ...gameState.playerPos };

    // 重新渲染游戏
    renderGame();
}

// 检查胜利条件
function checkWin() {
    return gameState.targets.every(target =>
        gameState.boxes.some(box => box.x === target.x && box.y === target.y)
    );
}

// 记录移动历史
function recordMove(dx, dy, boxIndex, newBoxX, newBoxY) {
    const historyEntry = {
        playerPos: deepCopy(gameState.playerPos),
        playerDirection: gameState.playerDirection,
        movedBoxIndex: boxIndex,
        boxPos: boxIndex !== -1 ? deepCopy(gameState.boxes[boxIndex]) : null
    };

    gameState.moveHistory.push(historyEntry);

    // 如果历史记录太长，可以限制最大记录数
    if (gameState.moveHistory.length > 100) {
        gameState.moveHistory.shift(); // 移除最早的记录
    }
}

// 撤销上一步
function undoMove() {
    // 如果玩家正在移动或者没有历史记录，则不能撤销
    if (gameState.isMoving || gameState.moveHistory.length === 0) {
        return;
    }

    // 获取上一步的状态
    const lastMove = gameState.moveHistory.pop();

    // 恢复玩家位置和方向
    gameState.playerPos = lastMove.playerPos;
    gameState.playerDirection = lastMove.playerDirection;
    gameState.startPos = { ...lastMove.playerPos };
    gameState.targetPos = { ...lastMove.playerPos };

    // 如果上一步涉及到移动箱子，恢复箱子位置
    if (lastMove.movedBoxIndex !== -1 && lastMove.boxPos) {
        gameState.boxes[lastMove.movedBoxIndex] = lastMove.boxPos;
    }

    // 减少移动次数
    if (gameState.moves > 0) {
        gameState.moves--;
    }

    // 重新渲染游戏
    renderGame();
}

// 移动玩家
function movePlayer(dx, dy) {
    if (gameState.isMoving) return; // 如果正在移动则忽略输入

    // 更新玩家位置
    const currentX = Math.round(gameState.playerPos.x);
    const currentY = Math.round(gameState.playerPos.y);
    gameState.playerPos = { x: currentX, y: currentY };

    // 计算新位置
    const newX = currentX + dx;
    const newY = currentY + dy;

    // 更新玩家朝向
    if (dx < 0) gameState.playerDirection = 'l';
    else if (dx > 0) gameState.playerDirection = 'r';
    else if (dy < 0) gameState.playerDirection = 'u';
    else if (dy > 0) gameState.playerDirection = 'd';

    // 检查是否撞墙
    if (gameState.board[newY][newX] === 'wall') {
        renderGame(); // 更新朝向
        return;
    }

    // 检查是否推箱子
    const boxIndex = gameState.boxes.findIndex(box =>
        Math.round(box.x) === newX && Math.round(box.y) === newY);

    if (boxIndex !== -1) {
        const newBoxX = newX + dx;
        const newBoxY = newY + dy;

        // 检查箱子是否可以移动
        if (gameState.board[newBoxY][newBoxX] === 'wall' ||
            gameState.boxes.some(box =>
                Math.round(box.x) === newBoxX && Math.round(box.y) === newBoxY)) {
            renderGame(); // 更新朝向
            return;
        }

        // 记录移动前的状态（用于撤销）
        recordMove(dx, dy, boxIndex, newBoxX, newBoxY);

        // 移动箱子
        gameState.boxes[boxIndex] = { x: newBoxX, y: newBoxY };
        gameState.boxPushes++;  // 增加箱子推动次数
    } else {
        // 记录移动前的状态（用于撤销）
        recordMove(dx, dy, -1, null, null);
    }

    // 设置移动起始点和目标点
    gameState.startPos = { x: currentX, y: currentY };
    gameState.targetPos = { x: newX, y: newY };
    gameState.animationStep = 0;  // 开始移动步骤
    gameState.animationFrame = 0; // 重置动画帧
    gameState.isMoving = true;    // 开始移动动画

    // 开始移动步骤
    animateStep();
}

// 移动步骤
function animateStep() {
    if (!gameState.isMoving) return;

    // 获取当前步骤和目标位置
    const startX = gameState.startPos.x;
    const startY = gameState.startPos.y;
    const targetX = gameState.targetPos.x;
    const targetY = gameState.targetPos.y;

    // 根据当前步骤设置相应的动画帧
    switch (gameState.animationStep) {
        case 0: // 第一步 - 显示00帧
            gameState.animationFrame = 0; // 对应帧00

            // 插值第一步: 起始点*0.75 + 终点*0.25
            gameState.playerPos = {
                x: startX * 0.75 + targetX * 0.25,
                y: startY * 0.75 + targetY * 0.25
            };

            renderGame();
            setTimeout(() => {
                gameState.animationStep = 1;
                animateStep();
            }, 20);
            break;

        case 1: // 第二步 - 显示01帧
            gameState.animationFrame = 1; // 对应帧01

            // 插值第二步: 起始点*0.5 + 终点*0.5
            gameState.playerPos = {
                x: startX * 0.5 + targetX * 0.5,
                y: startY * 0.5 + targetY * 0.5
            };

            renderGame();
            setTimeout(() => {
                gameState.animationStep = 2;
                animateStep();
            }, 20);
            break;

        case 2: // 第三步 - 显示02帧并移动玩家到目标位置
            gameState.animationFrame = 2; // 对应帧02

            // 插值第三步: 起始点*0.25 + 终点*0.75
            gameState.playerPos = {
                x: startX * 0.25 + targetX * 0.75,
                y: startY * 0.25 + targetY * 0.75
            };

            renderGame();

            // 移动完成
            setTimeout(() => {
                // 更新游戏状态
                gameState.playerPos = { x: targetX, y: targetY };
                gameState.isMoving = false;
                gameState.animationFrame = 0;
                gameState.moves++;

                // 检查是否获胜
                if (checkWin() && !winDialogShown) {
                    // 设置标志防止重复显示
                    winDialogShown = true;

                    // 创建基本的胜利消息
                    const baseMsg = getText('winMessage', {
                        moves: gameState.moves,
                        pushes: gameState.boxPushes
                    });

                    // 判断是否为最优解
                    if (gameState.boxPushes > gameState.minSolutionSteps && gameState.minSolutionSteps > 0) {
                        // 不是最优解，显示自定义确认对话框
                        const notOptimalMsg = getText('notOptimalSolution', {
                            minSteps: gameState.minSolutionSteps
                        });
                        const confirmMsg = getText('confirmReplay');

                        showCustomConfirm(
                            baseMsg + '\n' + notOptimalMsg + '\n' + confirmMsg,
                            () => {
                                winDialogShown = false; // 重置标志
                                resetLevel();
                            },
                            () => {
                                winDialogShown = false; // 重置标志
                                generateNewLevel();
                            }
                        );
                    } else {
                        // 最优解或无最优数据
                        const optimalMsg = gameState.minSolutionSteps > 0 ? '\n' + getText('optimalSolution') : '';
                        const confirmMsg = getText('confirmReplay');

                        showCustomConfirm(
                            baseMsg + optimalMsg + '\n\n' + confirmMsg,
                            () => {
                                winDialogShown = false; // 重置标志
                                resetLevel();
                            },
                            () => {
                                winDialogShown = false; // 重置标志
                                generateNewLevel();
                            }
                        );
                    }
                } else {
                    // 恢复最终状态
                    renderGame();
                }
            }, 20);
            break;
    }
}

// 创建默认图像
function createDefaultImages() {
    // 对象用于保存已创建的默认图像
    const defaultImages = {};

    // 1. 创建箱子图像
    const boxCanvas = document.createElement('canvas');
    boxCanvas.width = config.tileSize;
    boxCanvas.height = config.tileSize;
    const boxCtx = boxCanvas.getContext('2d');

    // 绘制木箱
    boxCtx.fillStyle = '#b97a57';  // 棕色
    boxCtx.fillRect(0, 0, config.tileSize, config.tileSize);
    // 绘制边框
    boxCtx.strokeStyle = '#5d3a1a';  // 深棕色
    boxCtx.lineWidth = 3;
    boxCtx.strokeRect(3, 3, config.tileSize - 6, config.tileSize - 6);
    // 绘制木纹
    boxCtx.strokeStyle = '#8c5a3d';  // 中棕色
    boxCtx.lineWidth = 1;
    for (let i = 8; i < config.tileSize; i += 8) {
        boxCtx.beginPath();
        boxCtx.moveTo(0, i);
        boxCtx.lineTo(config.tileSize, i);
        boxCtx.stroke();
    }

    defaultImages.box = boxCanvas.toDataURL();

    // 1.1 创建箱子在目标点上的图像
    const boxAidCanvas = document.createElement('canvas');
    boxAidCanvas.width = config.tileSize;
    boxAidCanvas.height = config.tileSize;
    const boxAidCtx = boxAidCanvas.getContext('2d');

    // 绘制彩色箱子（在目标点上）
    boxAidCtx.fillStyle = '#5cb85c';  // 绿色
    boxAidCtx.fillRect(0, 0, config.tileSize, config.tileSize);
    // 绘制边框
    boxAidCtx.strokeStyle = '#2d682d';  // 深绿色
    boxAidCtx.lineWidth = 3;
    boxAidCtx.strokeRect(3, 3, config.tileSize - 6, config.tileSize - 6);
    // 绘制图案
    boxAidCtx.strokeStyle = '#fff';  // 白色
    boxAidCtx.lineWidth = 2;
    // 绘制对勾
    boxAidCtx.beginPath();
    boxAidCtx.moveTo(config.tileSize * 0.25, config.tileSize * 0.5);
    boxAidCtx.lineTo(config.tileSize * 0.45, config.tileSize * 0.7);
    boxAidCtx.lineTo(config.tileSize * 0.75, config.tileSize * 0.3);
    boxAidCtx.stroke();

    defaultImages.boxAid = boxAidCanvas.toDataURL();

    // 2. 创建目标点图像
    const targetCanvas = document.createElement('canvas');
    targetCanvas.width = config.tileSize;
    targetCanvas.height = config.tileSize;
    const targetCtx = targetCanvas.getContext('2d');

    // 绘制基础地板
    targetCtx.fillStyle = '#eee';
    targetCtx.fillRect(0, 0, config.tileSize, config.tileSize);

    // 绘制十字标记
    targetCtx.fillStyle = '#f00';  // 红色
    targetCtx.beginPath();
    // 绘制圆圈
    targetCtx.arc(config.tileSize / 2, config.tileSize / 2, config.tileSize / 3, 0, Math.PI * 2);
    targetCtx.fill();
    // 绘制白色内圈
    targetCtx.fillStyle = '#fff';
    targetCtx.beginPath();
    targetCtx.arc(config.tileSize / 2, config.tileSize / 2, config.tileSize / 5, 0, Math.PI * 2);
    targetCtx.fill();

    defaultImages.target = targetCanvas.toDataURL();

    return defaultImages;
}

// 预加载图片
const images = {
    wall: new Image(),
    floor: new Image(),
    box: new Image(),
    boxAid: new Image(),  // 添加箱子在目标点上的图像
    target: new Image(),
    player: {}
};

// 预加载所有图片并等待加载完成
async function loadImages() {
    const loadPromises = [];
    const defaultImages = createDefaultImages();

    // 预加载玩家各方向的动画帧
    const directions = ['u', 'd', 'l', 'r'];
    const frames = ['00', '01', '02'];
    directions.forEach(dir => {
        images.player[dir] = {};
        frames.forEach(frame => {
            images.player[dir][frame] = new Image();
            const promise = new Promise((resolve) => {
                images.player[dir][frame].onload = resolve;
                images.player[dir][frame].onerror = () => {
                    // 即使图片加载失败也继续
                    resolve();
                };
                images.player[dir][frame].src = `img/player_${dir}_${frame}.png`;
            });
            loadPromises.push(promise);
        });
    });

    // 预加载其他图片
    const otherImages = ['wall', 'floor', 'box', 'boxAid', 'target'];
    otherImages.forEach(name => {
        const promise = new Promise((resolve) => {
            images[name].onload = resolve;
            images[name].onerror = () => {
                // 使用预先创建的默认图像
                if (name === 'box' && defaultImages.box) {
                    images[name].src = defaultImages.box;
                } else if (name === 'boxAid' && defaultImages.boxAid) {
                    images[name].src = defaultImages.boxAid;
                } else if (name === 'target' && defaultImages.target) {
                    images[name].src = defaultImages.target;
                } else {
                    // 创建一个临时的canvas作为替代
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = config.tileSize;
                    tempCanvas.height = config.tileSize;
                    const tempCtx = tempCanvas.getContext('2d');

                    // 根据不同类型绘制不同的替代图形
                    switch (name) {
                        case 'wall':
                            tempCtx.fillStyle = '#888';
                            tempCtx.fillRect(0, 0, config.tileSize, config.tileSize);
                            break;
                        case 'floor':
                            tempCtx.fillStyle = '#eee';
                            tempCtx.fillRect(0, 0, config.tileSize, config.tileSize);
                            break;
                        case 'box':
                            tempCtx.fillStyle = '#b97a57';
                            tempCtx.fillRect(0, 0, config.tileSize, config.tileSize);
                            tempCtx.strokeStyle = '#000';
                            tempCtx.lineWidth = 2;
                            tempCtx.strokeRect(2, 2, config.tileSize - 4, config.tileSize - 4);
                            break;
                        case 'boxAid':
                            tempCtx.fillStyle = '#5cb85c';
                            tempCtx.fillRect(0, 0, config.tileSize, config.tileSize);
                            tempCtx.strokeStyle = '#fff';
                            tempCtx.lineWidth = 2;
                            tempCtx.strokeRect(2, 2, config.tileSize - 4, config.tileSize - 4);
                            break;
                        case 'target':
                            tempCtx.fillStyle = '#eee';
                            tempCtx.fillRect(0, 0, config.tileSize, config.tileSize);
                            tempCtx.fillStyle = '#f00';
                            tempCtx.beginPath();
                            tempCtx.arc(config.tileSize / 2, config.tileSize / 2, config.tileSize / 4, 0, Math.PI * 2);
                            tempCtx.fill();
                            break;
                    }

                    // 使用canvas作为图像源
                    images[name].src = tempCanvas.toDataURL();
                }
                resolve();
            };

            // 设置图片源路径，特别处理 boxAid
            if (name === 'boxAid') {
                images[name].src = `img/Box_Aid.png`; // 尝试加载Box_Aid.png
            } else {
                images[name].src = `img/${name === 'target' ? 'Aid' : name}.png`;
            }
        });
        loadPromises.push(promise);
    });

    try {
        await Promise.all(loadPromises);
        return true;
    } catch (error) {
        console.error('图片加载失败:', error);
        return false;
    }
}

// 初始化Canvas和上下文
function initCanvas() {
    canvas = document.getElementById('game-canvas');
    if (!canvas) {
        console.error('找不到Canvas元素!');
        return false;
    }

    ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error('无法获取Canvas上下文!');
        return false;
    }

    // 计算适合屏幕的画布大小
    const container = document.getElementById('game-container');
    if (container) {
        // 获取可用屏幕宽度（考虑边距）
        const availableWidth = Math.min(window.innerWidth - 40, 600);

        // 计算合适的瓦片大小，考虑边界（最小和最大尺寸）
        let tileSize = Math.floor(availableWidth / config.boardSize.width);

        // 确保瓦片大小不要太小
        const minTileSize = 15; // 最小瓦片大小，支持更大地图
        const maxTileSize = 60; // 最大瓦片大小

        tileSize = Math.max(minTileSize, Math.min(maxTileSize, tileSize));

        // 更新配置
        config.tileSize = tileSize;
        config.canvasWidth = config.boardSize.width * tileSize;
        config.canvasHeight = config.boardSize.height * tileSize;

        // 设置画布大小
        canvas.width = config.canvasWidth;
        canvas.height = config.canvasHeight;

        // 设置容器大小
        container.style.width = `${config.canvasWidth}px`;
        container.style.height = `${config.canvasHeight}px`;

        console.log(`画布已调整为 ${config.canvasWidth}x${config.canvasHeight}, 瓦片大小: ${tileSize}px`);
    }

    return true;
}

// 添加触摸控制支持
function initTouchControls() {
    // 获取触摸按钮元素
    const touchUp = document.getElementById('touch-up');
    const touchDown = document.getElementById('touch-down');
    const touchLeft = document.getElementById('touch-left');
    const touchRight = document.getElementById('touch-right');

    // 处理触摸事件的函数
    function handleTouchStart(dx, dy) {
        return function (event) {
            event.preventDefault();
            movePlayer(dx, dy);
        };
    }

    // 添加触摸事件监听器
    if (touchUp) {
        touchUp.addEventListener('touchstart', handleTouchStart(0, -1));
    }
    if (touchDown) {
        touchDown.addEventListener('touchstart', handleTouchStart(0, 1));
    }
    if (touchLeft) {
        touchLeft.addEventListener('touchstart', handleTouchStart(-1, 0));
    }
    if (touchRight) {
        touchRight.addEventListener('touchstart', handleTouchStart(1, 0));
    }

    // 防止触摸控制时页面滚动
    const touchControls = document.getElementById('touch-controls');
    if (touchControls) {
        touchControls.addEventListener('touchmove', function (event) {
            event.preventDefault();
        }, { passive: false });
    }
}

// 监听窗口大小变化
window.addEventListener('resize', function () {
    // 重新初始化画布大小
    initCanvas();
    // 重新加载图片以适应新的瓦片大小
    loadImages().then(() => {
        // 重新渲染游戏
        renderGame();
    });
});

// 设置模态框函数
function openSettings() {
    // 填充当前设置值
    document.getElementById('board-size-range').min = 6;
    document.getElementById('board-size-range').max = 11;
    document.getElementById('board-size-range').value = config.boardSize.width;
    document.getElementById('board-size-value').textContent = `${config.boardSize.width}×${config.boardSize.width}`;

    document.getElementById('max-tries-range').value = config.aiGenerationMaxTries;
    document.getElementById('max-tries-value').textContent = config.aiGenerationMaxTries;

    // 加载求解器设置
    let maxIterationsValue = defaultSettings.maxSolverIterations;
    let maxNodesValue = defaultSettings.maxNodesInMemory;

    // 直接使用defaultSettings中的值，不需要创建临时实例
    // 因为设置已经保存在defaultSettings中了
    maxIterationsValue = defaultSettings.maxSolverIterations;
    maxNodesValue = defaultSettings.maxNodesInMemory;

    document.getElementById('max-iterations-range').value = maxIterationsValue;
    document.getElementById('max-iterations-value').textContent = maxIterationsValue;

    document.getElementById('max-nodes-range').value = maxNodesValue;
    document.getElementById('max-nodes-value').textContent = maxNodesValue;

    // 设置概率滑块的初始值
    document.getElementById('wall-prob-range').value = defaultSettings.wallProbability;
    document.getElementById('wall-prob-value').textContent = defaultSettings.wallProbability.toFixed(2);

    document.getElementById('box-prob-range').value = defaultSettings.boxProbability;
    document.getElementById('box-prob-value').textContent = defaultSettings.boxProbability.toFixed(2);

    // 显示模态框
    const modal = document.getElementById('settings-modal');
    modal.style.display = 'block';

    // 添加实时更新显示值的事件监听
    setupRangeListeners();

    // 移动端优化：防止背景滚动
    if (window.innerWidth <= 768) {
        document.body.style.overflow = 'hidden';
    }

    // 添加模态框点击外部关闭功能
    modal.addEventListener('click', function (e) {
        if (e.target === modal) {
            closeSettings();
        }
    });

    // 添加ESC键关闭功能
    const escKeyHandler = function (e) {
        if (e.key === 'Escape') {
            closeSettings();
            document.removeEventListener('keydown', escKeyHandler);
        }
    };
    document.addEventListener('keydown', escKeyHandler);

    // 焦点管理：聚焦到第一个可交互元素
    setTimeout(() => {
        const firstRange = document.getElementById('board-size-range');
        if (firstRange) {
            firstRange.focus();
        }
    }, 100);
}

// 设置范围滑块的监听器
function setupRangeListeners() {
    // 为每个滑块添加增强的事件监听器
    const rangeInputs = [
        {
            id: 'board-size-range',
            valueId: 'board-size-value',
            formatter: (value) => `${value}×${value}`
        },
        {
            id: 'max-tries-range',
            valueId: 'max-tries-value',
            formatter: (value) => value
        },
        {
            id: 'max-iterations-range',
            valueId: 'max-iterations-value',
            formatter: (value) => value
        },
        {
            id: 'max-nodes-range',
            valueId: 'max-nodes-value',
            formatter: (value) => value
        },
        {
            id: 'wall-prob-range',
            valueId: 'wall-prob-value',
            formatter: (value) => parseFloat(value).toFixed(2)
        },
        {
            id: 'box-prob-range',
            valueId: 'box-prob-value',
            formatter: (value) => parseFloat(value).toFixed(2)
        }
    ];

    rangeInputs.forEach(({ id, valueId, formatter }) => {
        const rangeElement = document.getElementById(id);
        const valueElement = document.getElementById(valueId);

        if (rangeElement && valueElement) {
            // 添加input事件监听器（实时更新）
            rangeElement.addEventListener('input', function () {
                valueElement.textContent = formatter(this.value);
            });

            // 添加change事件监听器（最终值确认）
            rangeElement.addEventListener('change', function () {
                valueElement.textContent = formatter(this.value);
            });

            // 移动端优化：添加触摸事件支持
            if ('ontouchstart' in window) {
                rangeElement.addEventListener('touchstart', function () {
                    this.style.transform = 'scale(1.05)';
                });

                rangeElement.addEventListener('touchend', function () {
                    this.style.transform = 'scale(1)';
                });
            }

            // 键盘导航支持
            rangeElement.addEventListener('keydown', function (e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' ||
                    e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    // 延迟更新以确保值已改变
                    setTimeout(() => {
                        valueElement.textContent = formatter(this.value);
                    }, 10);
                }
            });
        }
    });
}

// 保存设置
function saveSettings() {
    // 获取设置值
    const boardSize = parseInt(document.getElementById('board-size-range').value);
    const maxTries = parseInt(document.getElementById('max-tries-range').value);
    const maxIterations = parseInt(document.getElementById('max-iterations-range').value);
    const maxNodes = parseInt(document.getElementById('max-nodes-range').value);
    const wallProb = parseFloat(document.getElementById('wall-prob-range').value);
    const boxProb = parseFloat(document.getElementById('box-prob-range').value);

    // 检查尺寸是否发生变化
    const sizeChanged = config.boardSize.width !== boardSize || config.boardSize.height !== boardSize;

    // 更新配置
    config.boardSize = { width: boardSize, height: boardSize };
    config.aiGenerationMaxTries = maxTries;

    // 更新默认设置
    defaultSettings.wallProbability = wallProb;
    defaultSettings.boxProbability = boxProb;
    defaultSettings.maxSolverIterations = maxIterations;
    defaultSettings.maxNodesInMemory = maxNodes;

    console.log(`设置已保存: 求解器最大迭代次数=${maxIterations}, 最大内存节点数=${maxNodes}`);

    // 如果AILevelGenerator已加载，更新其设置
    if (AILevelGenerator) {
        try {
            // 修改AILevelGenerator类的默认值
            AILevelGenerator.prototype.maxSolverIterations = maxIterations;
            AILevelGenerator.prototype.wallProbability = wallProb;
            AILevelGenerator.prototype.boxProbability = boxProb;

            // 如果可以访问Solver，更新其设置
            if (window.Solver) {
                window.Solver.prototype.maxNodesInMemory = maxNodes;
            }
        } catch (e) {
            console.warn("无法更新求解器设置:", e);
        }
    }

    // 保存设置到本地存储以供下次使用
    try {
        const settingsToSave = {
            boardSize: config.boardSize,
            aiGenerationMaxTries: config.aiGenerationMaxTries,
            maxSolverIterations: maxIterations,
            maxNodesInMemory: maxNodes,
            wallProbability: wallProb,
            boxProbability: boxProb
        };
        localStorage.setItem('sokobanSettings', JSON.stringify(settingsToSave));
    } catch (e) {
        console.warn("无法保存设置到本地存储:", e);
    }

    // 关闭设置模态框
    closeSettings();

    // 如果尺寸发生变化，重新初始化画布并生成新关卡
    if (sizeChanged) {
        // 重新初始化画布大小
        initCanvas();

        // 重新加载图片以适应新的瓦片大小
        loadImages().then(() => {
            // 生成新关卡
            generateNewLevel();
        });

        // 提示用户设置已保存并应用
        showCustomAlert(getText('sizeChanged'));
    } else {
        // 提示用户设置已保存
        showCustomAlert(getText('settingsSaved'));
    }
}

// 重置设置为默认值
function resetSettings() {
    showCustomConfirm(getText('confirmReset'), () => {
        // 检查尺寸是否发生变化
        const sizeChanged = config.boardSize.width !== defaultSettings.boardSize.width ||
            config.boardSize.height !== defaultSettings.boardSize.height;

        // 重置配置
        config.boardSize = deepCopy(defaultSettings.boardSize);
        config.aiGenerationMaxTries = defaultSettings.aiGenerationMaxTries;
        config.aiTimeout = defaultSettings.aiTimeout;

        // 重置求解器设置
        if (AILevelGenerator) {
            AILevelGenerator.prototype.maxSolverIterations = defaultSettings.maxSolverIterations;
        }

        if (window.Solver) {
            window.Solver.prototype.maxNodesInMemory = defaultSettings.maxNodesInMemory;
        }

        // 删除本地存储中的设置
        try {
            localStorage.removeItem('sokobanSettings');
        } catch (e) {
            console.warn("无法删除本地存储中的设置:", e);
        }

        // 重新打开设置面板以显示默认值
        openSettings();

        // 如果尺寸发生变化，重新初始化画布并生成新关卡
        if (sizeChanged) {
            // 关闭设置模态框
            closeSettings();

            // 重新初始化画布大小
            initCanvas();

            // 重新加载图片以适应新的瓦片大小
            loadImages().then(() => {
                // 生成新关卡
                generateNewLevel();
            });

            // 提示用户设置已重置并应用
            showCustomAlert(getText('settingsReset'));
        }
    });
}

// 应用推荐设置
function applyRecommendedSettings() {
    const message = `推荐设置基于算法优化，平衡了性能和关卡质量：

🎯 关卡尺寸: 8×8 (适中复杂度)
🤖 最大尝试次数: 150 (良好质量/时间平衡)
🧠 最大迭代次数: 25000 (2.5万，高成功率)
💾 最大内存节点数: 50000 (5万，充足内存)
🧱 墙壁概率: 0.28 (适中密度)
📦 箱子概率: 0.22 (适中难度)

注：AI求解演示固定使用25万迭代+50万内存，不受此设置影响

是否应用这些推荐设置？`;

    showCustomConfirm(message, () => {
        // 应用推荐设置（确保尺寸在11x11范围内）
        document.getElementById('board-size-range').value = 8;
        document.getElementById('board-size-value').textContent = '8×8';

        document.getElementById('max-tries-range').value = 150;
        document.getElementById('max-tries-value').textContent = '150';

        document.getElementById('max-iterations-range').value = 25000;
        document.getElementById('max-iterations-value').textContent = '25000';

        document.getElementById('max-nodes-range').value = 50000;
        document.getElementById('max-nodes-value').textContent = '50000';

        document.getElementById('wall-prob-range').value = 0.28;
        document.getElementById('wall-prob-value').textContent = '0.28';

        document.getElementById('box-prob-range').value = 0.22;
        document.getElementById('box-prob-value').textContent = '0.22';

        showCustomAlert(getText('recommendedApplied'));
    });
}

// 从本地存储加载设置
function loadSettings() {
    try {
        const savedSettings = localStorage.getItem('sokobanSettings');
        if (savedSettings) {
            const settings = JSON.parse(savedSettings);

            // 更新配置
            if (settings.boardSize) config.boardSize = settings.boardSize;
            if (settings.aiGenerationMaxTries) config.aiGenerationMaxTries = settings.aiGenerationMaxTries;
            if (settings.aiTimeout) config.aiTimeout = settings.aiTimeout;

            // 保存求解器设置以便在加载时应用
            if (settings.maxSolverIterations) defaultSettings.maxSolverIterations = settings.maxSolverIterations;
            if (settings.maxNodesInMemory) defaultSettings.maxNodesInMemory = settings.maxNodesInMemory;
            if (settings.wallProbability) defaultSettings.wallProbability = settings.wallProbability;
            if (settings.boxProbability) defaultSettings.boxProbability = settings.boxProbability;

            console.log(`已从本地存储加载设置: 求解器最大迭代次数=${defaultSettings.maxSolverIterations}, 最大内存节点数=${defaultSettings.maxNodesInMemory}`);
        }
    } catch (e) {
        console.warn("无法从本地存储加载设置:", e);
    }
}

// 在AI关卡生成器导入后应用求解器设置
function applySettingsToSolver(solverModule) {
    try {
        if (solverModule && solverModule.Solver) {
            solverModule.Solver.prototype.maxNodesInMemory = defaultSettings.maxNodesInMemory;
            console.log('已应用求解器设置');
        }
    } catch (e) {
        console.warn("无法应用求解器设置:", e);
    }
}

// 修改初始化游戏函数，添加设置按钮事件和加载设置
async function initGame() {
    // 从本地存储加载语言设置
    try {
        const savedLanguage = localStorage.getItem('sokobanLanguage');
        if (savedLanguage) {
            currentLanguage = savedLanguage;
        }
    } catch (e) {
        console.warn("无法从本地存储加载语言设置:", e);
    }

    // 初始化Canvas和上下文
    const canvasInitialized = initCanvas();

    if (!canvasInitialized) {
        displayErrorMessage('游戏初始化失败：无法找到或初始化Canvas元素');
        return;
    }

    // 从本地存储加载设置
    loadSettings();

    // 初始化触摸控制
    initTouchControls();

    // 设置按钮和相关函数
    window.openSettings = openSettings;
    window.closeSettings = closeSettings;
    window.saveSettings = saveSettings;
    window.resetSettings = resetSettings;

    // 加载AI关卡生成器模块
    try {
        if (config.useAIGeneration && !AILevelGenerator) {
            const aiModule = await import('./js/AILevelGenerator.js');
            AILevelGenerator = aiModule.AILevelGenerator;

            // 应用求解器设置到AILevelGenerator
            AILevelGenerator.prototype.maxSolverIterations = defaultSettings.maxSolverIterations;

            // 尝试导入并设置Solver模块
            try {
                const solverModule = await import('./js/Solver.js');
                window.Solver = solverModule.Solver;
                applySettingsToSolver(solverModule);
            } catch (e) {
                console.warn("无法导入Solver模块:", e);
            }
        }
    } catch (error) {
        console.error('AI关卡生成器加载失败:', error);
        config.useAIGeneration = false; // 禁用AI生成关卡
    }

    // 加载图片
    const imagesLoaded = await loadImages();
    if (imagesLoaded) {
        // 更新页面文本为当前语言
        updatePageText();

        // 生成新关卡
        await generateNewLevel();

        // 将游戏状态预渲染到屏幕上 - 开始游戏循环
        window.requestAnimationFrame(gameLoop);
    } else {
        showCustomAlert('图片加载失败，请刷新页面重试');
    }
}

// 显示错误信息
function displayErrorMessage(message) {
    const errorElement = document.getElementById('error-message');
    if (errorElement) {
        errorElement.style.display = 'block';
        errorElement.innerHTML = message + ' <button id="retry-btn">重试</button>';

        // 添加重试按钮事件
        setTimeout(() => {
            const retryBtn = document.getElementById('retry-btn');
            if (retryBtn) {
                retryBtn.addEventListener('click', function () {
                    errorElement.style.display = 'none';
                    initGame();
                });
            }
        }, 0);
    } else {
        showCustomAlert(message);
    }
}

// 游戏循环
function gameLoop(timestamp) {
    // 渲染游戏
    renderGame();

    // 继续请求下一帧
    window.requestAnimationFrame(gameLoop);
}

// 等待DOM加载完成后再初始化游戏
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGame);
} else {
    // 如果DOM已经加载完成，直接初始化
    initGame();
}

// 不要立即调用initGame，改为在DOM加载完成后调用
// initGame();

// 暴露撤销函数给全局，以便HTML按钮可以调用
window.undoMove = undoMove;
window.resetLevel = resetLevel;
window.generateNewLevel = generateNewLevel;
window.aiDemonstration = aiDemonstration;
window.getText = getText; // 暴露getText函数到全局

// AI演示相关变量
let aiDemoInProgress = false;
let aiDemoSteps = [];
let aiDemoCurrentStep = 0;
let aiDemoInterval = null;
let aiDemoPaused = false;
let winDialogShown = false; // 防止重复显示胜利对话框
const AI_DEMO_STEP_DELAY = 300; // 演示每步延迟(毫秒)

/**
 * AI演示功能
 * 自动求解当前关卡并演示最优解
 */
async function aiDemonstration() {
    // 如果玩家正在移动或正在生成关卡，则不响应
    if (gameState.isMoving || gameState.generatingLevel) {
        return;
    }

    // 如果演示已经在进行中
    if (aiDemoInProgress) {
        // 如果暂停中，继续演示
        if (aiDemoPaused) {
            resumeAiDemo();
        }
        // 否则暂停演示
        else {
            pauseAiDemo();
        }
        return;
    }

    // 重置当前关卡状态
    resetLevel();

    // 标记AI演示开始
    aiDemoInProgress = true;
    aiDemoPaused = false;
    const demoBtn = document.getElementById('ai-demo-btn');
    if (demoBtn) {
        demoBtn.textContent = getText('pauseBtn');
        demoBtn.disabled = false;
    }

    // 创建用于求解的State对象
    const solverState = await createSolverState();
    if (!solverState) {
        console.error('创建求解状态失败');
        endAiDemo();
        return;
    }

    // 求解当前关卡 (使用AI演示专用的高参数求解器)
    try {
        const solution = await solvePuzzleForDemo(solverState);
        if (!solution || solution.length === 0) {
            console.error('AI演示未找到解决方案');
            showCustomAlert(getText('aiFailed'));
            endAiDemo();
            return;
        }

        // 准备AI演示步骤
        prepareAiDemoSteps(solution);

        // 开始执行AI演示
        aiDemoInterval = setInterval(executeNextAiDemoStep, AI_DEMO_STEP_DELAY);
    } catch (error) {
        console.error('AI演示求解过程出错:', error);
        showCustomAlert('AI演示过程出错，请重试。');
        endAiDemo();
    }
}

/**
 * 暂停AI演示
 */
function pauseAiDemo() {
    if (!aiDemoInProgress || aiDemoPaused) return;

    // 清除定时器
    if (aiDemoInterval) {
        clearInterval(aiDemoInterval);
        aiDemoInterval = null;
    }

    // 标记为暂停
    aiDemoPaused = true;

    // 更新按钮文本
    const demoBtn = document.getElementById('ai-demo-btn');
    if (demoBtn) {
        demoBtn.textContent = getText('resumeBtn');
    }

    console.log('AI演示已暂停');
}

/**
 * 继续AI演示
 */
function resumeAiDemo() {
    if (!aiDemoInProgress || !aiDemoPaused) return;

    // 重新开始定时器
    aiDemoInterval = setInterval(executeNextAiDemoStep, AI_DEMO_STEP_DELAY);

    // 取消暂停标记
    aiDemoPaused = false;

    // 更新按钮文本
    const demoBtn = document.getElementById('ai-demo-btn');
    if (demoBtn) {
        demoBtn.textContent = getText('pauseBtn');
    }

    console.log('AI演示已继续');
}

/**
 * 执行下一个AI演示步骤
 */
function executeNextAiDemoStep() {
    if (aiDemoCurrentStep >= aiDemoSteps.length) {
        // 所有步骤完成，显示完成对话框
        showAiDemoComplete();
        return;
    }

    // 如果玩家正在移动，等待移动完成
    if (gameState.isMoving) {
        return;
    }

    // 获取当前步骤
    const step = aiDemoSteps[aiDemoCurrentStep];

    // 执行移动
    movePlayer(step.dx, step.dy);

    // 移动到下一步
    aiDemoCurrentStep++;

    // 更新AI演示进度显示
    //updateAiDemoProgress();

    // 在移动日志中记录当前进度
    console.log(getText('aiStepProgress', { current: aiDemoCurrentStep, total: aiDemoSteps.length }));
}

/**
 * 更新AI演示进度显示
 */
function updateAiDemoProgress() {
    if (!aiDemoInProgress) {
        // 如果演示已经结束，清除进度显示
        const aiProgressElem = document.getElementById('ai-progress');
        if (aiProgressElem) {
            aiProgressElem.style.display = 'none';
        }
        return;
    }

    // 获取或创建进度显示元素
    let aiProgressElem = document.getElementById('ai-progress');
    if (!aiProgressElem) {
        aiProgressElem = document.createElement('div');
        aiProgressElem.id = 'ai-progress';
        aiProgressElem.style.position = 'absolute';
        aiProgressElem.style.bottom = '10px';
        aiProgressElem.style.left = '10px';
        aiProgressElem.style.background = 'rgba(0, 0, 0, 0.6)';
        aiProgressElem.style.color = 'white';
        aiProgressElem.style.padding = '5px 10px';
        aiProgressElem.style.borderRadius = '4px';
        aiProgressElem.style.fontSize = '14px';
        aiProgressElem.style.zIndex = '100';

        // 添加到游戏容器
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
            gameContainer.appendChild(aiProgressElem);
        }
    }

    // 更新进度显示
    const percentage = Math.floor((aiDemoCurrentStep / aiDemoSteps.length) * 100);
    aiProgressElem.textContent = ``;
    aiProgressElem.style.display = 'block';
}

/**
 * 显示AI演示完成对话框
 */
function showAiDemoComplete() {
    // 先结束AI演示状态
    endAiDemo();

    // 检查是否已经显示了胜利对话框
    if (winDialogShown) {
        return; // 如果已经显示了胜利对话框，就不再显示AI完成对话框
    }

    // 设置标志防止重复显示
    winDialogShown = true;

    // 显示自定义确认对话框
    const message = getText('aiReplay');
    showCustomConfirm(
        message,
        () => {
            winDialogShown = false; // 重置标志
            resetLevel();
        },
        () => {
            winDialogShown = false; // 重置标志
            generateNewLevel();
        }
    );
}

/**
 * 结束AI演示
 */
function endAiDemo() {
    // 清除定时器
    if (aiDemoInterval) {
        clearInterval(aiDemoInterval);
        aiDemoInterval = null;
    }


    // 重置AI演示状态
    aiDemoInProgress = false;
    aiDemoPaused = false;
    aiDemoSteps = [];
    aiDemoCurrentStep = 0;

    // 清除进度显示
    updateAiDemoProgress();

    // 恢复按钮状态
    const demoBtn = document.getElementById('ai-demo-btn');
    if (demoBtn) {
        demoBtn.textContent = getText('aiDemoBtn');
        demoBtn.disabled = false;
    }

    console.log('AI演示结束');

}

/**
 * 创建用于求解的State对象
 */
async function createSolverState() {
    try {
        // 导入必要的模块
        const { State } = await import('./js/State.js');
        const { TileType } = await import('./js/GenerateLevel.js');

        // 创建状态对象
        const state = new State(config.boardSize.width, config.boardSize.height);

        // 初始化瓦片数组
        let tiles = new Array(config.boardSize.height * config.boardSize.width);

        // 将游戏状态转换为求解器需要的状态
        for (let i = 0; i < config.boardSize.height; i++) {
            for (let j = 0; j < config.boardSize.width; j++) {
                // 默认为地板
                let tileType = TileType.Floor;

                // 检查当前位置是什么类型
                if (gameState.board[i][j] === 'wall') {
                    tileType = TileType.Wall;
                }

                // 检查是否是目标点
                const isTarget = gameState.targets.some(
                    target => target.x === j && target.y === i
                );

                // 检查是否有箱子
                const boxIndex = gameState.boxes.findIndex(
                    box => box.x === j && box.y === i
                );

                // 检查是否是角色位置
                const isPlayer = gameState.playerPos.x === j && gameState.playerPos.y === i;

                // 根据组合情况设置瓦片类型
                if (isPlayer) {
                    tileType = isTarget ? TileType.CharacterinAid : TileType.Character;
                } else if (boxIndex !== -1) {
                    tileType = isTarget ? TileType.BoxinAid : TileType.Box;
                } else if (isTarget) {
                    tileType = TileType.Aid;
                }

                // 保存到瓦片数组
                tiles[i * config.boardSize.width + j] = tileType;
            }
        }

        // 设置关卡
        state.setLevel(tiles);
        return state;
    } catch (error) {
        console.error('创建求解器状态时出错:', error);
        return null;
    }
}

/**
 * 求解推箱子关卡 (用于AI生成关卡时的验证)
 * @param {State} state - 初始状态
 * @returns {Array} 解决步骤
 */
async function solvePuzzle(state) {
    try {
        // 导入求解器
        const { Solver } = await import('./js/Solver.js');

        // 创建求解器实例
        const solver = new Solver(state);

        // 使用设置中的最大迭代次数 (用于AI生成关卡验证)
        solver.maxIterations = defaultSettings.maxSolverIterations || 15000;
        solver.maxNodesInMemory = defaultSettings.maxNodesInMemory || 30000;

        console.log(`AI生成关卡验证使用参数: 最大迭代次数=${solver.maxIterations}, 最大内存节点数=${solver.maxNodesInMemory}`);

        // 执行求解
        const result = solver.run();

        if (result === 1) {
            console.log('找到解决方案，步骤数:', solver.steplist.length - 1);
            console.log('解决方案:', solver.steplist);
            return solver.steplist;
        } else if (result === -1) {
            console.error('关卡无解');
            return null;
        } else {
            console.error('求解超时');
            return null;
        }
    } catch (error) {
        console.error('求解过程出错:', error);
        return null;
    }
}

/**
 * AI求解演示专用函数 (使用最高参数)
 * @param {State} state - 初始状态
 * @returns {Array} 解决步骤
 */
async function solvePuzzleForDemo(state) {
    try {
        // 导入求解器
        const { Solver } = await import('./js/Solver.js');

        // 创建求解器实例
        const solver = new Solver(state);

        // 使用最高参数确保能够解决复杂关卡
        solver.maxIterations = 250000;  // 25万次迭代
        solver.maxNodesInMemory = 500000;  // 50万内存节点

        console.log(`AI求解演示使用最高参数: 最大迭代次数=${solver.maxIterations}, 最大内存节点数=${solver.maxNodesInMemory}`);

        // 执行求解
        const result = solver.run();

        if (result === 1) {
            console.log('AI演示找到解决方案，步骤数:', solver.steplist.length - 1);
            return solver.steplist;
        } else if (result === -1) {
            console.error('关卡无解');
            return null;
        } else {
            console.error('AI演示求解超时');
            return null;
        }
    } catch (error) {
        console.error('AI演示求解过程出错:', error);
        return null;
    }
}

/**
 * 准备AI演示步骤
 * @param {Array} solution - 求解器返回的解决方案
 */
function prepareAiDemoSteps(solution) {
    aiDemoSteps = [];
    let lastPlayerPos = {
        x: solution[0].currentstate.cx,
        y: solution[0].currentstate.cy
    };

    // 跳过第一个状态（初始状态）
    for (let i = 1; i < solution.length; i++) {
        const currentNode = solution[i];
        const prevNode = solution[i - 1];

        console.log('第' + i + '步状态:');
        var stateshow = "";
        for (let j = 0; j < currentNode.currentstate.height; j++) {
            for (let k = 0; k < currentNode.currentstate.width; k++) {
                stateshow += currentNode.currentstate.tiles[j * currentNode.currentstate.width + k] + " ";
            }
            stateshow += "\n";
        }
        console.log(stateshow);

        // 调试信息
        console.log(`处理步骤 ${i}/${solution.length - 1}`, {
            lastPos: lastPlayerPos,
            currentState: currentNode.currentstate
        });

        // 计算角色从上一状态到当前状态的移动
        if (currentNode && prevNode) {
            const currentPlayerPos = {
                x: currentNode.currentstate.cx,
                y: currentNode.currentstate.cy
            };

            // 检测箱子移动
            const movedBoxInfo = findMovedBox(prevNode.currentstate, currentNode.currentstate);

            if (movedBoxInfo) {
                const { prevPos, currentPos } = movedBoxInfo;
                console.log("movedBoxInfo", prevPos, currentPos);
                // 计算推箱子的方向
                const dx = currentPos.x - prevPos.x;
                const dy = currentPos.y - prevPos.y;

                // 验证移动方向的有效性
                if (Math.abs(dx) + Math.abs(dy) !== 1) {
                    console.error('无效的箱子移动方向', { dx, dy });
                    continue;
                }

                // 计算玩家推箱子的位置
                const playerPosBeforePush = {
                    x: prevPos.x - dx,
                    y: prevPos.y - dy
                };

                // 验证玩家位置的有效性
                if (playerPosBeforePush.x < 0 || playerPosBeforePush.x >= prevNode.currentstate.width ||
                    playerPosBeforePush.y < 0 || playerPosBeforePush.y >= prevNode.currentstate.height) {
                    console.error('无效的玩家位置', playerPosBeforePush);
                    continue;
                }

                // 寻找到推箱子位置的路径
                const pathToBox = findPath(
                    lastPlayerPos.x, lastPlayerPos.y,
                    playerPosBeforePush.x, playerPosBeforePush.y,
                    prevNode.currentstate
                );

                if (pathToBox.length === 0 &&
                    !(lastPlayerPos.x === playerPosBeforePush.x &&
                        lastPlayerPos.y === playerPosBeforePush.y)) {

                    console.warn('寻找替代路径到箱子位置', {
                        from: lastPlayerPos,
                        to: playerPosBeforePush
                    });

                    const alternativePath = findAlternativePath(
                        lastPlayerPos,
                        playerPosBeforePush,
                        prevNode.currentstate
                    );

                    if (alternativePath.length > 0) {
                        console.log('找到替代路径');
                        // 验证替代路径
                        if (validatePath(alternativePath, prevNode.currentstate)) {
                            for (let j = 1; j < alternativePath.length; j++) {
                                const moveX = alternativePath[j].x - alternativePath[j - 1].x;
                                const moveY = alternativePath[j].y - alternativePath[j - 1].y;
                                aiDemoSteps.push({ dx: moveX, dy: moveY });
                            }
                        }
                    }
                } else {
                    // 添加到箱子位置的移动步骤
                    for (let j = 1; j < pathToBox.length; j++) {
                        const moveX = pathToBox[j].x - pathToBox[j - 1].x;
                        const moveY = pathToBox[j].y - pathToBox[j - 1].y;
                        aiDemoSteps.push({ dx: moveX, dy: moveY });
                    }
                }

                // 添加推箱子的步骤
                aiDemoSteps.push({ dx, dy });
                lastPlayerPos = { x: prevPos.x, y: prevPos.y };
            } else if (lastPlayerPos.x !== currentPlayerPos.x || lastPlayerPos.y !== currentPlayerPos.y) {
                // 处理玩家纯移动
                const playerPath = findPath(
                    lastPlayerPos.x, lastPlayerPos.y,
                    currentPlayerPos.x, currentPlayerPos.y,
                    prevNode.currentstate
                );

                if (playerPath.length > 0 && validatePath(playerPath, prevNode.currentstate)) {
                    for (let j = 1; j < playerPath.length; j++) {
                        const moveX = playerPath[j].x - playerPath[j - 1].x;
                        const moveY = playerPath[j].y - playerPath[j - 1].y;
                        aiDemoSteps.push({ dx: moveX, dy: moveY });
                    }
                    lastPlayerPos = { ...currentPlayerPos };
                } else {
                    console.warn('尝试替代路径进行玩家移动');
                    const alternativePath = findAlternativePath(
                        lastPlayerPos,
                        currentPlayerPos,
                        prevNode.currentstate
                    );
                    if (alternativePath.length > 0 && validatePath(alternativePath, prevNode.currentstate)) {
                        for (let j = 1; j < alternativePath.length; j++) {
                            const moveX = alternativePath[j].x - alternativePath[j - 1].x;
                            const moveY = alternativePath[j].y - alternativePath[j - 1].y;
                            aiDemoSteps.push({ dx: moveX, dy: moveY });
                        }
                        lastPlayerPos = { ...currentPlayerPos };
                    }
                }
            }
        }
    }

    aiDemoCurrentStep = 0;
    console.log(`AI演示准备就绪，共${aiDemoSteps.length}步`, aiDemoSteps);
}

/**
 * 寻找替代路径
 * @param {Object} start - 起始位置
 * @param {Object} target - 目标位置
 * @param {State} state - 游戏状态
 * @returns {Array} 路径数组
 */
function findAlternativePath(start, target, state) {
    // 尝试不同的中间点
    const midPoints = [
        { x: start.x, y: target.y },
        { x: target.x, y: start.y },
        { x: start.x - 1, y: start.y },
        { x: start.x + 1, y: start.y },
        { x: start.x, y: start.y - 1 },
        { x: start.x, y: start.y + 1 }
    ];

    for (const mid of midPoints) {
        // 检查中间点是否在地图范围内
        if (mid.x < 0 || mid.y < 0 || mid.x >= state.width || mid.y >= state.height) {
            continue;
        }

        // 尝试通过中间点寻路
        const path1 = findPath(start.x, start.y, mid.x, mid.y, state);
        if (path1.length > 0) {
            const path2 = findPath(mid.x, mid.y, target.x, target.y, state);
            if (path2.length > 0) {
                // 合并路径，去除重复的中间点
                return [...path1, ...path2.slice(1)];
            }
        }
    }

    return [];
}

/**
 * 查找哪个箱子被移动了
 * @param {State} prevState - 前一状态
 * @param {State} currentState - 当前状态
 * @returns {Object|null} 移动的箱子信息
 */
function findMovedBox(prevState, currentState) {
    // 找出哪个箱子被移动了
    const width = prevState.width;
    const height = prevState.height;
    var prevBox = { x: -1, y: -1 };
    var currentBox = { x: -1, y: -1 };
    for (let i = 0; i < height; i++) {
        for (let j = 0; j < width; j++) {
            if (prevState.tiles[i * width + j] === 1 || prevState.tiles[i * width + j] === 2) {
                console.log("prevBox", j, i, prevState.tiles[i * width + j], currentState.tiles[i * width + j]);
                // 目标点变为墙，即使不一样也不作为可移动的箱子
                if (prevState.tiles[i * width + j] == 2 && currentState.tiles[i * width + j] == 5) {
                    continue;
                }
                if (currentState.tiles[i * width + j] !== prevState.tiles[i * width + j]) {
                    prevBox.x = j;
                    prevBox.y = i;
                }
            }
        }
    }
    /*
    if(prevBox === null){
        return null;
    }
    */
    var adjx = [prevBox.x, prevBox.x, prevBox.x + 1, prevBox.x - 1];
    var adjy = [prevBox.y + 1, prevBox.y - 1, prevBox.y, prevBox.y];
    for (let i = 0; i < 4; i++) {
        if (adjx[i] < 0 || adjx[i] >= width || adjy[i] < 0 || adjy[i] >= height) {
            continue;
        }
        if (currentState.tiles[adjy[i] * width + adjx[i]] === 1 || currentState.tiles[adjy[i] * width + adjx[i]] === 2 || currentState.tiles[adjy[i] * width + adjx[i]] === 5) {
            console.log("currentBox", adjx[i], adjy[i], currentState.tiles[adjy[i] * width + adjx[i]], prevState.tiles[adjy[i] * width + adjx[i]]);
            if (currentState.tiles[adjy[i] * width + adjx[i]] !== prevState.tiles[adjy[i] * width + adjx[i]]) {
                currentBox.x = adjx[i];
                currentBox.y = adjy[i];
                break;
            }
        }
    }
    /*
    if(currentBox === null){
        return null;
    }
        */
    return {
        prevPos: { x: prevBox.x, y: prevBox.y },
        currentPos: { x: currentBox.x, y: currentBox.y }
    };

}

/**
 * 使用广度优先搜索（BFS）寻找路径
 * @param {number} startX - 起点X坐标
 * @param {number} startY - 起点Y坐标
 * @param {number} targetX - 目标X坐标
 * @param {number} targetY - 目标Y坐标
 * @param {State} state - 当前游戏状态
 * @returns {Array} 路径点数组
 */
function findPath(startX, startY, targetX, targetY, state) {
    // 如果起点和终点相同，直接返回
    if (startX === targetX && startY === targetY) {
        return [{ x: startX, y: startY }];
    }

    // 导入 TileType 的值
    const TileType = {
        Wall: 5,
        Box: 1,
        BoxinAid: 2
    };

    // 定义方向：上、右、下、左
    const directions = [
        { dx: 0, dy: -1, dir: 'up' },
        { dx: 1, dy: 0, dir: 'right' },
        { dx: 0, dy: 1, dir: 'down' },
        { dx: -1, dy: 0, dir: 'left' }
    ];

    // 创建访问标记数组
    const visited = Array(state.height).fill().map(() => Array(state.width).fill(false));

    // 创建前驱节点数组，用于重建路径
    const prev = Array(state.height).fill().map(() => Array(state.width).fill(null));

    // 创建方向数组，记录到达每个点的方向
    const directionMap = Array(state.height).fill().map(() => Array(state.width).fill(null));

    // 广度优先搜索队列
    const queue = [{ x: startX, y: startY }];
    visited[startY][startX] = true;

    // BFS寻路
    while (queue.length > 0) {
        const current = queue.shift();

        // 如果找到目标，重建路径并返回
        if (current.x === targetX && current.y === targetY) {
            const path = reconstructPath(prev, startX, startY, targetX, targetY);
            // 验证路径的有效性
            if (validatePath(path, state)) {
                return path;
            }
            // 如果路径无效，继续搜索
            continue;
        }

        // 尝试四个方向
        for (const dir of directions) {
            const nx = current.x + dir.dx;
            const ny = current.y + dir.dy;

            // 检查边界
            if (nx < 0 || ny < 0 || nx >= state.width || ny >= state.height) {
                continue;
            }

            // 检查是否已经访问过
            if (visited[ny][nx]) {
                continue;
            }

            // 检查是否是墙壁或箱子
            const tile = state.tiles[ny * state.width + nx];
            if (tile === TileType.Wall || tile === TileType.Box || tile === TileType.BoxinAid) {
                // 如果是目标位置，则允许经过
                if (!(nx === targetX && ny === targetY)) {
                    continue;
                }
            }

            // 标记为已访问
            visited[ny][nx] = true;
            prev[ny][nx] = { x: current.x, y: current.y };
            directionMap[ny][nx] = dir.dir;
            queue.push({ x: nx, y: ny });
        }
    }

    // 如果没有找到路径，返回空数组
    return [];
}

/**
 * 验证路径的有效性
 * @param {Array} path - 路径数组
 * @param {State} state - 游戏状态
 * @returns {boolean} 路径是否有效
 */
function validatePath(path, state) {
    if (!path || path.length < 2) return true;

    const TileType = {
        Wall: 5,
        Box: 1,
        BoxinAid: 2
    };

    // 检查每一步是否有效
    for (let i = 1; i < path.length; i++) {
        const current = path[i];
        const prev = path[i - 1];

        // 计算移动方向
        const dx = current.x - prev.x;
        const dy = current.y - prev.y;

        // 检查是否是有效的单步移动
        if (Math.abs(dx) + Math.abs(dy) !== 1) {
            console.warn('无效的移动步骤：非相邻格子', { from: prev, to: current });
            return false;
        }

        // 检查目标格子是否可通行
        const tile = state.tiles[current.y * state.width + current.x];
        if (tile === TileType.Wall) {
            console.warn('无效的移动步骤：撞墙', { pos: current });
            return false;
        }

        // 检查是否穿过箱子（除非是终点）
        if ((tile === TileType.Box || tile === TileType.BoxinAid) &&
            !(current.x === path[path.length - 1].x && current.y === path[path.length - 1].y)) {
            console.warn('无效的移动步骤：穿过箱子', { pos: current });
            return false;
        }
    }

    return true;
}

/**
 * 重建从起点到终点的路径
 * @param {Array} prev - 前驱节点数组
 * @param {number} startX - 起点X坐标
 * @param {number} startY - 起点Y坐标
 * @param {number} targetX - 目标X坐标
 * @param {number} targetY - 目标Y坐标
 * @returns {Array} 路径点数组
 */
function reconstructPath(prev, startX, startY, targetX, targetY) {
    const path = [];
    let current = { x: targetX, y: targetY };

    // 从终点回溯到起点
    while (current !== null && !(current.x === startX && current.y === startY)) {
        path.unshift(current);
        current = prev[current.y][current.x];
    }

    // 添加起点
    path.unshift({ x: startX, y: startY });

    return path;
}

// 在canvas下方显示当前已推动次数
function updatePushCountDisplay() {
    let pushInfo = document.getElementById('push-info');
    if (!pushInfo) {
        // 如果没有则创建
        pushInfo = document.createElement('div');
        pushInfo.id = 'push-info';
        pushInfo.style.marginTop = '10px';
        pushInfo.style.fontSize = '1.1em';
        pushInfo.style.color = '#333';
        // 插入到canvas下方
        const container = document.getElementById('game-container');
        if (container && container.parentNode) {
            container.parentNode.insertBefore(pushInfo, container.nextSibling);
        }
    }
    pushInfo.textContent = getText('boxPushes', { count: gameState.boxPushes });
}

// 渲染游戏
function renderGame() {
    // 检查ctx是否有效
    if (!ctx) {
        console.error('无法渲染游戏：Canvas上下文不可用');
        return;
    }

    // 清除画布
    ctx.clearRect(0, 0, config.canvasWidth, config.canvasHeight);

    // 首先绘制所有格子的地板
    for (let y = 0; y < config.boardSize.height; y++) {
        for (let x = 0; x < config.boardSize.width; x++) {
            const posX = x * config.tileSize;
            const posY = y * config.tileSize;

            // 绘制地面
            if (images.floor && images.floor.complete && images.floor.naturalWidth !== 0) {
                ctx.drawImage(images.floor, posX, posY, config.tileSize, config.tileSize);
            } else {
                // 如果图片加载失败，使用简单的矩形
                ctx.fillStyle = '#eee';
                ctx.fillRect(posX, posY, config.tileSize, config.tileSize);
            }
        }
    }

    // 渲染墙壁
    for (let y = 0; y < config.boardSize.height; y++) {
        for (let x = 0; x < config.boardSize.width; x++) {
            if (gameState.board[y][x] === 'wall') {
                const posX = x * config.tileSize;
                const posY = y * config.tileSize;

                if (images.wall && images.wall.complete && images.wall.naturalWidth !== 0) {
                    ctx.drawImage(images.wall, posX, posY, config.tileSize, config.tileSize);
                } else {
                    // 如果图片加载失败，使用简单的矩形
                    ctx.fillStyle = '#888';
                    ctx.fillRect(posX, posY, config.tileSize, config.tileSize);
                }
            }
        }
    }

    // 渲染目标点
    gameState.targets.forEach(target => {
        const posX = target.x * config.tileSize;
        const posY = target.y * config.tileSize;

        if (images.target && images.target.complete && images.target.naturalWidth !== 0) {
            ctx.drawImage(images.target, posX, posY, config.tileSize, config.tileSize);
        } else {
            // 如果图片加载失败，使用简单的图形
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(posX + config.tileSize / 2, posY + config.tileSize / 2, config.tileSize / 4, 0, Math.PI * 2);
            ctx.fill();
        }
    });

    // 渲染箱子
    gameState.boxes.forEach(box => {
        const posX = box.x * config.tileSize;
        const posY = box.y * config.tileSize;

        // 检查箱子是否在目标点上
        const isOnTarget = gameState.targets.some(target =>
            Math.round(target.x) === Math.round(box.x) &&
            Math.round(target.y) === Math.round(box.y)
        );

        // 根据箱子是否在目标点上选择不同的图像
        if (isOnTarget) {
            // 箱子在目标点上
            if (images.boxAid && images.boxAid.complete && images.boxAid.naturalWidth !== 0) {
                ctx.drawImage(images.boxAid, posX, posY, config.tileSize, config.tileSize);
            } else {
                // 如果图片加载失败，使用简单的绿色矩形表示箱子在目标点上
                ctx.fillStyle = '#5cb85c';  // 绿色
                ctx.fillRect(posX, posY, config.tileSize, config.tileSize);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(posX + 2, posY + 2, config.tileSize - 4, config.tileSize - 4);

                // 绘制对勾
                ctx.beginPath();
                ctx.moveTo(posX + config.tileSize * 0.25, posY + config.tileSize * 0.5);
                ctx.lineTo(posX + config.tileSize * 0.45, posY + config.tileSize * 0.7);
                ctx.lineTo(posX + config.tileSize * 0.75, posY + config.tileSize * 0.3);
                ctx.stroke();
            }
        } else {
            // 普通箱子
            if (images.box && images.box.complete && images.box.naturalWidth !== 0) {
                ctx.drawImage(images.box, posX, posY, config.tileSize, config.tileSize);
            } else {
                // 如果图片加载失败，使用简单的矩形
                ctx.fillStyle = '#b97a57';
                ctx.fillRect(posX, posY, config.tileSize, config.tileSize);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(posX + 2, posY + 2, config.tileSize - 4, config.tileSize - 4);
            }
        }
    });

    // 渲染玩家
    renderPlayer();
    // 新增：渲染后更新推动次数显示
    updatePushCountDisplay();
}

// 渲染玩家
function renderPlayer() {
    // 选择合适的玩家图片
    let frame = '00';
    if (gameState.isMoving) {
        // 动画帧直接映射
        if (gameState.animationFrame === 0) frame = '00';
        else if (gameState.animationFrame === 1) frame = '01';
        else if (gameState.animationFrame === 2) frame = '02';
    }

    const posX = gameState.playerPos.x * config.tileSize;
    const posY = gameState.playerPos.y * config.tileSize;

    // 检查玩家图像是否存在
    const playerImgLoaded = images.player &&
        images.player[gameState.playerDirection] &&
        images.player[gameState.playerDirection][frame] &&
        images.player[gameState.playerDirection][frame].complete &&
        images.player[gameState.playerDirection][frame].naturalWidth !== 0;

    if (playerImgLoaded) {
        // 绘制玩家图片
        ctx.drawImage(images.player[gameState.playerDirection][frame], posX, posY, config.tileSize, config.tileSize);
    } else {
        // 如果图片没有加载成功，使用简单的形状代替
        ctx.fillStyle = '#00f';
        ctx.fillRect(posX + 4, posY + 4, config.tileSize - 8, config.tileSize - 8);
        ctx.fillStyle = '#fff';

        // 根据方向绘制不同的简单标记
        const center = config.tileSize / 2;
        ctx.beginPath();
        if (gameState.playerDirection === 'u') {
            ctx.moveTo(posX + center, posY + 8);
            ctx.lineTo(posX + center - 6, posY + center);
            ctx.lineTo(posX + center + 6, posY + center);
        } else if (gameState.playerDirection === 'd') {
            ctx.moveTo(posX + center, posY + config.tileSize - 8);
            ctx.lineTo(posX + center - 6, posY + center);
            ctx.lineTo(posX + center + 6, posY + center);
        } else if (gameState.playerDirection === 'l') {
            ctx.moveTo(posX + 8, posY + center);
            ctx.lineTo(posX + center, posY + center - 6);
            ctx.lineTo(posX + center, posY + center + 6);
        } else if (gameState.playerDirection === 'r') {
            ctx.moveTo(posX + config.tileSize - 8, posY + center);
            ctx.lineTo(posX + center, posY + center - 6);
            ctx.lineTo(posX + center, posY + center + 6);
        }
        ctx.fill();
    }
}

// 监听键盘事件
document.addEventListener('keydown', (event) => {
    switch (event.key.toLowerCase()) {
        case 'arrowleft':
        case 'a':
            movePlayer(-1, 0);
            break;
        case 'arrowright':
        case 'd':
            movePlayer(1, 0);
            break;
        case 'arrowup':
        case 'w':
            movePlayer(0, -1);
            break;
        case 'arrowdown':
        case 's':
            movePlayer(0, 1);
            break;
        case 'z':
        case 'backspace':
            undoMove();
            break;
    }
});

// 关闭设置模态框
function closeSettings() {
    const modal = document.getElementById('settings-modal');
    modal.style.display = 'none';

    // 移动端优化：恢复背景滚动
    if (window.innerWidth <= 768) {
        document.body.style.overflow = '';
    }

    // 移除事件监听器
    modal.removeEventListener('click', closeSettings);
}

// 存储关卡功能
window.saveLevel = function () {
    // 提取墙壁位置
    const walls = [];
    for (let y = 0; y < gameState.board.length; y++) {
        for (let x = 0; x < gameState.board[y].length; x++) {
            if (gameState.board[y][x] === 'wall') {
                walls.push({ x, y });
            }
        }
    }

    // 创建关卡数据
    const levelData = {
        boardSize: config.boardSize,
        walls: walls.map(wall => ({ x: wall.x, y: wall.y })),
        boxes: gameState.boxes.map(box => ({ x: box.x, y: box.y })),
        targets: gameState.targets.map(target => ({ x: target.x, y: target.y })),
        playerPos: { x: gameState.playerPos.x, y: gameState.playerPos.y },
        minSolutionSteps: gameState.minSolutionSteps || 0,
        iterations: currentLevelIterations || 1,
        wallCount: walls.length
    };

    // 将数据转换为JSON字符串
    const jsonString = JSON.stringify(levelData, null, 2);

    // 创建一个Blob对象
    const blob = new Blob([jsonString], { type: 'application/json' });

    // 创建一个临时的URL链接
    const url = window.URL.createObjectURL(blob);

    // 创建一个临时的<a>元素
    const link = document.createElement('a');
    link.href = url;

    // 设置文件名
    const date = new Date();
    const dateString = `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
    const timeString = `${date.getHours().toString().padStart(2, '0')}${date.getMinutes().toString().padStart(2, '0')}${date.getSeconds().toString().padStart(2, '0')}`;
    link.download = `sokoban_level_${dateString}_${timeString}.json`;

    // 将<a>元素添加到DOM中
    document.body.appendChild(link);

    // 模拟点击<a>元素
    link.click();

    // 移除<a>元素
    document.body.removeChild(link);

    // 释放URL对象
    window.URL.revokeObjectURL(url);

    // 同时保存到localStorage作为备份
    try {
        localStorage.setItem('lastSavedLevel', jsonString);
        console.log('关卡已保存到本地存储');
    } catch (e) {
        console.error('无法保存关卡到本地存储:', e);
    }

    showCustomAlert(getText('levelSaved'));
};

// 加载关卡功能
window.loadLevel = function () {
    // 创建文件输入元素
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.json';
    fileInput.style.display = 'none';

    // 添加文件选择事件监听器
    fileInput.addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (!file) {
            console.log('没有选择文件');

            // 尝试从localStorage加载最后保存的关卡
            tryLoadFromLocalStorage();
            return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                console.log('读取到文件内容:', e.target.result.substring(0, 100) + '...');

                // 解析JSON数据
                const levelData = JSON.parse(e.target.result);
                console.log('解析后的关卡数据:', JSON.stringify(levelData, null, 2).substring(0, 200) + '...');

                // 加载关卡
                const success = loadLevelFromData(levelData);

                if (success) {
                    // 显示成功消息
                    showCustomAlert(getText('loadLevelSuccess'));
                }
            } catch (error) {
                console.error("解析关卡数据失败:", error);
                console.error("错误详情:", error.message);
                console.error("文件内容片段:", e.target.result.substring(0, 200));
                showCustomAlert(getText('loadLevelFail') + "\n错误信息: " + error.message);
            }
        };

        reader.onerror = function (error) {
            console.error("读取文件失败:", error);
            showCustomAlert(getText('loadLevelFail') + "\n读取文件错误");
        };

        // 读取文件内容
        reader.readAsText(file);
    });

    // 触发文件选择对话框
    document.body.appendChild(fileInput);
    fileInput.click();

    // 清理
    setTimeout(() => {
        document.body.removeChild(fileInput);
    }, 1000);
};

// 从关卡数据加载关卡的通用函数
function loadLevelFromData(levelData) {
    console.log("开始加载关卡数据");

    // 检查关卡数据的有效性
    if (!levelData) {
        console.error("无效的关卡数据: 数据为空");
        showCustomAlert("无效的关卡数据: 数据为空");
        return false;
    }

    try {
        // 适配不同格式的关卡数据
        const width = levelData.width || (levelData.boardSize ? levelData.boardSize.width : null);
        const height = levelData.height || (levelData.boardSize ? levelData.boardSize.height : null);
        const player = levelData.player || levelData.playerPos;
        const boxes = levelData.boxes;
        const targets = levelData.targets;
        const walls = levelData.walls;

        console.log("检查关键数据:", {
            width, height,
            playerExists: !!player,
            boxesCount: boxes ? boxes.length : 0,
            targetsCount: targets ? targets.length : 0,
            wallsCount: walls ? walls.length : 0
        });

        if (!width || !height) {
            console.error("无效的关卡数据: 缺少尺寸信息");
            showCustomAlert("无效的关卡数据: 缺少棋盘尺寸信息");
            return false;
        }

        if (!player || typeof player.x !== 'number' || typeof player.y !== 'number') {
            console.error("无效的关卡数据: 缺少有效的玩家位置");
            showCustomAlert("无效的关卡数据: 缺少有效的玩家位置");
            return false;
        }

        if (!Array.isArray(boxes) || boxes.length === 0) {
            console.error("无效的关卡数据: 缺少箱子数据");
            showCustomAlert("无效的关卡数据: 缺少箱子数据");
            return false;
        }

        if (!Array.isArray(targets) || targets.length === 0) {
            console.error("无效的关卡数据: 缺少目标点数据");
            showCustomAlert("无效的关卡数据: 缺少目标点数据");
            return false;
        }

        // 设置棋盘尺寸
        config.boardSize.width = width;
        config.boardSize.height = height;

        // 重置当前游戏状态
        gameState.moves = 0;
        gameState.boxPushes = 0;
        gameState.playerDirection = 'd';
        gameState.isMoving = false;
        gameState.animationFrame = 0;
        gameState.animationStep = 0;
        gameState.moveHistory = [];

        // 初始化新的游戏板
        initializeBoard();

        // 加载墙壁
        let wallCount = 0;
        if (Array.isArray(walls)) {
            for (const wall of walls) {
                if (wall.x >= 0 && wall.x < width && wall.y >= 0 && wall.y < height) {
                    gameState.board[wall.y][wall.x] = 'wall';
                    wallCount++;
                }
            }
        }

        // 加载箱子
        gameState.boxes = [];
        for (const box of boxes) {
            if (box.x >= 0 && box.x < width && box.y >= 0 && box.y < height) {
                gameState.boxes.push({ x: box.x, y: box.y });
            }
        }

        // 加载目标点
        gameState.targets = [];
        for (const target of targets) {
            if (target.x >= 0 && target.x < width && target.y >= 0 && target.y < height) {
                gameState.targets.push({ x: target.x, y: target.y });
            }
        }

        // 加载玩家位置
        if (player.x >= 0 && player.x < width && player.y >= 0 && player.y < height) {
            gameState.playerPos = { x: player.x, y: player.y };
        } else {
            console.error("玩家位置超出棋盘范围");
            gameState.playerPos = { x: 1, y: 1 }; // 默认位置
        }
        gameState.startPos = { ...gameState.playerPos };
        gameState.targetPos = { ...gameState.playerPos };

        // 更新AI关卡信息
        gameState.minSolutionSteps = levelData.minSteps || levelData.minSolutionSteps || 0;
        currentLevelIterations = levelData.generationIterations || levelData.iterations || 1;
        updateAILevelInfo(gameState.minSolutionSteps, currentLevelIterations, wallCount);

        // 保存原始状态用于重置
        saveInitialState();

        // 初始化画布尺寸
        initCanvas();

        // 重新加载图片以适应新的尺寸
        loadImages().then(() => {
            // 渲染游戏
            renderGame();
        });

        console.log("关卡加载成功");
        return true;
    } catch (error) {
        console.error("加载关卡数据过程中发生错误:", error);
        showCustomAlert("加载关卡数据失败: " + error.message);
        return false;
    }
}

// 人工搭建关卡功能 - 已实现在之前的代码中，保持不变

// 建造模式变量
let buildMode = false;
let selectedTile = null;
let buildModeModal = null;
let buildModeToolbar = null;

// 人工搭建关卡功能
window.buildLevel = function () {
    console.log("开始人工搭建关卡");

    // 如果已经在建造模式，不做任何操作
    if (buildMode) {
        console.log("已经在建造模式中，操作取消");
        return;
    }

    // 如果AI演示正在进行，先结束演示
    if (aiDemoInProgress) {
        endAiDemo();
    }

    buildMode = true;
    console.log("进入建造模式");

    // 保存当前关卡状态以备取消时恢复
    const savedState = {
        board: deepCopy(gameState.board),
        boxes: deepCopy(gameState.boxes),
        targets: deepCopy(gameState.targets),
        playerPos: deepCopy(gameState.playerPos),
        boardWidth: config.boardSize.width,
        boardHeight: config.boardSize.height
    };
    console.log("已保存当前关卡状态用于恢复");

    // 不再默认清空场景，保留当前场景状态
    // 注意：这里不再调用initializeBoard()和清空boxes、targets、playerPos等

    // 创建建造模式界面
    createBuildModeUI();

    // 添加画布点击事件
    const gameCanvas = document.getElementById('game-canvas');
    gameCanvas.addEventListener('click', handleBuildModeClick);
    console.log("已添加画布点击事件监听器");

    // 禁用其他按钮
    document.getElementById('reset-btn').disabled = true;
    document.getElementById('new-level-btn').disabled = true;
    document.getElementById('undo-btn').disabled = true;
    document.getElementById('ai-demo-btn').disabled = true;
    document.getElementById('save-level-btn').disabled = true;
    document.getElementById('load-level-btn').disabled = true;
    console.log("已禁用其他功能按钮");

    // 渲染当前场景
    renderGame();

    // 定义取消函数 - 在局部作用域内定义
    cancelBuildMode = function () {
        console.log("执行取消建造模式操作");

        // 恢复之前的关卡状态
        gameState.board = savedState.board;
        gameState.boxes = savedState.boxes;
        gameState.targets = savedState.targets;
        gameState.playerPos = savedState.playerPos;
        config.boardSize.width = savedState.boardWidth;
        config.boardSize.height = savedState.boardHeight;
        console.log("已恢复之前的关卡状态");

        // 移除建造模式界面
        removeBuildModeUI();

        // 移除画布点击事件监听
        gameCanvas.removeEventListener('click', handleBuildModeClick);
        console.log("已移除画布点击事件监听器");

        // 启用其他按钮
        document.getElementById('reset-btn').disabled = false;
        document.getElementById('new-level-btn').disabled = false;
        document.getElementById('undo-btn').disabled = false;
        document.getElementById('ai-demo-btn').disabled = false;
        document.getElementById('save-level-btn').disabled = false;
        document.getElementById('load-level-btn').disabled = false;
        console.log("已重新启用其他功能按钮");

        buildMode = false;

        // 重新渲染游戏
        renderGame();
        console.log("已退出建造模式");
    };

    // 定义确认函数 - 在局部作用域内定义
    confirmBuildLevel = async function () {
        console.log("执行确认建造完成操作");

        // 验证关卡是否有效 - 仅检查基础结构，不再验证是否可解
        if (!validateBuiltLevel()) {
            console.log("关卡验证失败，已取消确认操作");
            return; // 已经在validateBuiltLevel中显示了错误信息，这里直接返回
        }

        // 保存初始状态用于重置
        saveInitialState();
        console.log("已保存当前关卡为初始状态");

        // 移除建造模式界面
        removeBuildModeUI();

        // 移除画布点击事件监听
        const gameCanvas = document.getElementById('game-canvas');
        if (gameCanvas) {
            gameCanvas.removeEventListener('click', handleBuildModeClick);
        }
        console.log("已移除画布点击事件监听器");

        // 启用其他按钮
        document.getElementById('reset-btn').disabled = false;
        document.getElementById('new-level-btn').disabled = false;
        document.getElementById('undo-btn').disabled = false;
        document.getElementById('ai-demo-btn').disabled = false;
        document.getElementById('save-level-btn').disabled = false;
        document.getElementById('load-level-btn').disabled = false;
        console.log("已重新启用其他功能按钮");

        buildMode = false;

        // 计算和更新关卡基本信息
        let wallCount = countTiles('wall');
        let boxCount = gameState.boxes.length;
        let targetCount = gameState.targets.length;

        console.log(`关卡基本数据: 尺寸=${config.boardSize.width}×${config.boardSize.height}, ` +
            `墙壁=${wallCount}, 箱子=${boxCount}, 目标点=${targetCount}`);

        // 更新基本关卡信息
        updateBuildLevelInfo(0, 1, wallCount, boxCount);

        // 显示成功消息
        showCustomAlert(getText('buildLevelSuccess'));

        // 添加自定义标记，显示这是玩家创建的关卡
        const aiInfo = document.getElementById('ai-info');
        if (aiInfo) {
            aiInfo.innerHTML += `<br><span style="color:#27ae60">【玩家自建关卡】</span>`;
        }

        // 重新渲染游戏
        renderGame();
        console.log("已完成关卡构建，退出建造模式");
    };

    // 删除使用说明弹窗
    // alert(getText('buildLevelInstructions')); // 这行被删除了
};

// 移除建造模式界面
function removeBuildModeUI() {
    console.log("移除建造模式界面");

    if (buildModeModal && buildModeModal.parentNode) {
        buildModeModal.parentNode.removeChild(buildModeModal);
        buildModeModal = null;
        console.log("建造模式界面已移除");
    } else {
        console.log("未找到建造模式界面元素，无需移除");
    }
}

// 创建建造模式界面
function createBuildModeUI() {
    console.log("创建建造模式界面");

    // 创建模态框容器
    buildModeModal = document.createElement('div');
    buildModeModal.id = 'build-mode-panel';
    buildModeModal.style.position = 'relative'; // 改为相对定位，不遮挡游戏区域
    buildModeModal.style.width = '100%';
    buildModeModal.style.maxWidth = '600px'; // 添加最大宽度限制
    buildModeModal.style.margin = '10px auto'; // 设置上下边距10px，左右自动居中
    buildModeModal.style.backgroundColor = '#f5f7fa'; // 浅灰蓝色背景，更现代清爽
    buildModeModal.style.zIndex = '100';
    buildModeModal.style.display = 'flex';
    buildModeModal.style.flexDirection = 'column';
    buildModeModal.style.alignItems = 'center';
    buildModeModal.style.padding = '15px';
    buildModeModal.style.boxSizing = 'border-box';
    buildModeModal.style.borderTop = '2px solid #3498db'; // 蓝色边框
    buildModeModal.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)'; // 添加阴影效果
    buildModeModal.style.borderRadius = '8px'; // 圆角

    // 创建两列布局容器
    const panelContent = document.createElement('div');
    panelContent.style.display = 'flex';
    panelContent.style.width = '100%';
    panelContent.style.maxWidth = '580px'; // 略小于父容器的最大宽度
    panelContent.style.gap = '20px';
    panelContent.style.alignItems = 'flex-start';

    // 左侧工具栏和工具选择
    const leftColumn = document.createElement('div');
    leftColumn.style.flex = '1';
    leftColumn.style.display = 'flex';
    leftColumn.style.flexDirection = 'column';
    leftColumn.style.alignItems = 'center';

    // 右侧设置和按钮
    const rightColumn = document.createElement('div');
    rightColumn.style.flex = '1';
    rightColumn.style.display = 'flex';
    rightColumn.style.flexDirection = 'column';
    rightColumn.style.alignItems = 'center';

    // 创建标题
    const title = document.createElement('h2');
    title.textContent = getText('buildLevelTitle');
    title.style.color = '#2c3e50'; // 深蓝灰色
    title.style.margin = '5px 0 15px 0';
    title.style.fontSize = '24px';
    title.style.fontWeight = '600';
    buildModeModal.appendChild(title);

    // 创建说明文本
    const instructions = document.createElement('p');
    instructions.textContent = getText('buildLevelInstructions');
    instructions.style.color = '#7f8c8d'; // 灰色
    instructions.style.margin = '0 0 15px 0';
    instructions.style.textAlign = 'center';
    instructions.style.fontSize = '14px';
    instructions.style.maxWidth = '700px';
    buildModeModal.appendChild(instructions);

    // 左侧标题
    const toolsTitle = document.createElement('h3');
    toolsTitle.textContent = '工具选择';
    toolsTitle.style.color = '#2c3e50';
    toolsTitle.style.margin = '10px 0';
    toolsTitle.style.fontSize = '16px';
    toolsTitle.style.alignSelf = 'flex-start';
    leftColumn.appendChild(toolsTitle);

    // 创建工具栏
    buildModeToolbar = document.createElement('div');
    buildModeToolbar.id = 'build-mode-toolbar';
    buildModeToolbar.style.display = 'flex';
    buildModeToolbar.style.flexWrap = 'wrap';
    buildModeToolbar.style.gap = '10px';
    buildModeToolbar.style.justifyContent = 'flex-start';
    buildModeToolbar.style.width = '100%';
    buildModeToolbar.style.margin = '10px 0';
    buildModeToolbar.style.padding = '10px';
    buildModeToolbar.style.backgroundColor = 'white'; // 白色背景
    buildModeToolbar.style.borderRadius = '8px';
    buildModeToolbar.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';

    // 定义工具按钮
    const tools = [
        { id: 'player', name: getText('buildLevelPlayer'), color: '#3498db', icon: '👤' },
        { id: 'wall', name: getText('buildLevelWall'), color: '#7f8c8d', icon: '🧱' },
        { id: 'box', name: getText('buildLevelBox'), color: '#e67e22', icon: '📦' },
        { id: 'target', name: getText('buildLevelTarget'), color: '#2ecc71', icon: '🎯' },
        { id: 'floor', name: getText('buildLevelFloor'), color: '#ecf0f1', icon: '⬜' }
    ];

    // 创建工具按钮
    tools.forEach(tool => {
        const button = document.createElement('button');
        button.innerHTML = `<span style="margin-right:5px;">${tool.icon}</span> ${tool.name}`;
        button.id = `build-${tool.id}`;
        button.style.padding = '10px 15px';
        button.style.backgroundColor = tool.color;
        button.style.color = tool.id === 'floor' ? '#333' : 'white';
        button.style.border = 'none';
        button.style.borderRadius = '5px';
        button.style.cursor = 'pointer';
        button.style.fontSize = '14px';
        button.style.display = 'flex';
        button.style.alignItems = 'center';
        button.style.justifyContent = 'center';
        button.style.fontWeight = 'bold';
        button.style.transition = 'all 0.2s ease';
        button.style.width = 'calc(50% - 5px)'; // 每行两个按钮
        button.style.boxSizing = 'border-box';
        button.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';

        button.addEventListener('mouseover', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
        });

        button.addEventListener('mouseout', () => {
            if (selectedTile !== tool.id) {
                button.style.transform = 'none';
                button.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
            }
        });

        button.addEventListener('click', () => {
            // 移除之前选中的按钮的选中状态
            document.querySelectorAll('#build-mode-toolbar button').forEach(btn => {
                btn.style.transform = 'none';
                btn.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
            });

            // 设置当前选中的工具
            selectedTile = tool.id;
            console.log(`已选择工具: ${tool.name} (${tool.id})`);

            // 添加选中样式
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15), 0 0 0 2px #3498db';
        });

        buildModeToolbar.appendChild(button);
    });

    leftColumn.appendChild(buildModeToolbar);

    // 将左右两列添加到面板中
    panelContent.appendChild(leftColumn);
    panelContent.appendChild(rightColumn);
    buildModeModal.appendChild(panelContent);

    // 创建清空场景按钮
    const clearSceneButton = document.createElement('button');
    clearSceneButton.textContent = getText('clearSceneBtn');
    clearSceneButton.id = 'clear-scene-btn';
    clearSceneButton.style.padding = '10px 15px';
    clearSceneButton.style.backgroundColor = '#9b59b6'; // 紫色
    clearSceneButton.style.color = 'white';
    clearSceneButton.style.border = 'none';
    clearSceneButton.style.borderRadius = '5px';
    clearSceneButton.style.cursor = 'pointer';
    clearSceneButton.style.fontSize = '14px';
    clearSceneButton.style.marginTop = '15px';
    clearSceneButton.style.fontWeight = 'bold';
    clearSceneButton.style.width = '100%';
    clearSceneButton.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
    clearSceneButton.style.transition = 'all 0.2s ease';

    // 绑定点击事件
    clearSceneButton.onclick = function () {
        console.log("点击了清空场景按钮");
        showCustomConfirm(getText('confirmClearScene'), () => {
            clearCurrentScene();
        });
    };

    leftColumn.appendChild(clearSceneButton);

    // 右侧标题
    const settingsTitle = document.createElement('h3');
    settingsTitle.textContent = '关卡设置';
    settingsTitle.style.color = '#2c3e50';
    settingsTitle.style.margin = '10px 0';
    settingsTitle.style.fontSize = '16px';
    settingsTitle.style.alignSelf = 'flex-start';
    rightColumn.appendChild(settingsTitle);

    // 创建关卡尺寸控制
    const sizeControl = document.createElement('div');
    sizeControl.style.display = 'flex';
    sizeControl.style.alignItems = 'center';
    sizeControl.style.width = '100%';
    sizeControl.style.padding = '15px';
    sizeControl.style.backgroundColor = 'white';
    sizeControl.style.borderRadius = '8px';
    sizeControl.style.marginTop = '10px';
    sizeControl.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';

    const sizeLabel = document.createElement('label');
    sizeLabel.textContent = getText('boardSize') + ': ';
    sizeLabel.style.color = '#2c3e50';
    sizeLabel.style.marginRight = '10px';
    sizeLabel.style.fontWeight = 'bold';
    sizeControl.appendChild(sizeLabel);

    const sizeSelect = document.createElement('select');
    sizeSelect.id = 'build-board-size';
    sizeSelect.style.padding = '8px 10px';
    sizeSelect.style.borderRadius = '4px';
    sizeSelect.style.border = '1px solid #ddd';
    sizeSelect.style.flex = '1';
    sizeSelect.style.backgroundColor = '#fff';
    sizeSelect.style.fontSize = '14px';
    sizeSelect.style.color = '#2c3e50';
    sizeSelect.style.cursor = 'pointer';
    sizeSelect.style.outline = 'none';

    // 添加尺寸选项
    for (let size = 6; size <= 11; size++) {  // 修改最大值为11
        const option = document.createElement('option');
        option.value = size;
        option.textContent = `${size}×${size}`;
        // 默认选中当前尺寸
        if (size === config.boardSize.width) {
            option.selected = true;
        }
        sizeSelect.appendChild(option);
    }

    // 添加尺寸改变事件
    sizeSelect.addEventListener('change', function () {
        const newSize = parseInt(this.value);
        console.log(`尺寸选择改变: ${newSize}×${newSize}`);
        // 确认是否要改变尺寸
        const confirmMessage = currentLanguage === 'zh' ?
            `确定要将关卡尺寸改为 ${newSize}×${newSize} 吗？\n超出新尺寸范围的元素将被移除。` :
            `Are you sure you want to change the level size to ${newSize}×${newSize}?\nElements outside the new size will be removed.`;
        showBuildModeConfirm(confirmMessage, () => {
            // 保存当前已放置的元素
            const savedElements = {
                boxes: gameState.boxes.filter(box => box.x < newSize && box.y < newSize),
                targets: gameState.targets.filter(target => target.x < newSize && target.y < newSize),
                player: (gameState.playerPos.x < newSize && gameState.playerPos.y < newSize) ?
                    gameState.playerPos : { x: -1, y: -1 }
            };

            // 更新尺寸
            config.boardSize.width = newSize;
            config.boardSize.height = newSize;

            // 初始化新游戏板
            initializeBoard();

            // 恢复已放置的元素
            gameState.boxes = savedElements.boxes;
            gameState.targets = savedElements.targets;
            gameState.playerPos = savedElements.player;

            // 调整画布尺寸
            initCanvas();

            // 重新渲染
            renderGame();
            console.log(`已更改尺寸为 ${newSize}×${newSize}`);
        }, () => {
            // 取消时还原选择
            for (let i = 0; i < sizeSelect.options.length; i++) {
                if (parseInt(sizeSelect.options[i].value) === config.boardSize.width) {
                    sizeSelect.selectedIndex = i;
                    break;
                }
            }
        });
    });

    sizeControl.appendChild(sizeSelect);
    rightColumn.appendChild(sizeControl);

    // 不再需要验证状态显示区域

    // 创建按钮容器
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.justifyContent = 'space-between';
    buttonContainer.style.width = '100%';
    buttonContainer.style.marginTop = '15px';

    // 创建取消按钮
    const cancelButton = document.createElement('button');
    cancelButton.textContent = getText('buildLevelCancel');
    cancelButton.id = 'build-cancel-btn';
    cancelButton.style.padding = '12px 20px';
    cancelButton.style.backgroundColor = '#e74c3c';
    cancelButton.style.color = 'white';
    cancelButton.style.border = 'none';
    cancelButton.style.borderRadius = '5px';
    cancelButton.style.cursor = 'pointer';
    cancelButton.style.fontSize = '14px';
    cancelButton.style.fontWeight = 'bold';
    cancelButton.style.marginRight = '10px';
    cancelButton.style.flex = '1';
    cancelButton.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
    cancelButton.style.transition = 'all 0.2s ease';

    // 直接绑定点击事件，不使用window对象
    cancelButton.onclick = function () {
        console.log("点击了取消按钮");
        cancelBuildMode();
    };

    buttonContainer.appendChild(cancelButton);

    // 创建确认按钮
    const confirmButton = document.createElement('button');
    confirmButton.textContent = getText('buildLevelConfirm');
    confirmButton.id = 'build-confirm-btn';
    confirmButton.style.padding = '12px 20px';
    confirmButton.style.backgroundColor = '#2ecc71';
    confirmButton.style.color = 'white';
    confirmButton.style.border = 'none';
    confirmButton.style.borderRadius = '5px';
    confirmButton.style.cursor = 'pointer';
    confirmButton.style.fontSize = '14px';
    confirmButton.style.fontWeight = 'bold';
    confirmButton.style.flex = '1';
    confirmButton.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
    confirmButton.style.transition = 'all 0.2s ease';

    // 直接绑定点击事件，不使用window对象
    confirmButton.onclick = function () {
        console.log("点击了确认按钮");
        confirmBuildLevel();
    };

    buttonContainer.appendChild(confirmButton);
    rightColumn.appendChild(buttonContainer);

    // 找到游戏容器并插入在其后面(而不是内部)
    const gameContainer = document.getElementById('game-container');
    if (gameContainer && gameContainer.parentNode) {
        gameContainer.parentNode.insertBefore(buildModeModal, gameContainer.nextSibling);
    } else {
        // 如果找不到游戏容器，则添加到body
        document.body.appendChild(buildModeModal);
    }

    // 默认选中玩家工具
    setTimeout(() => {
        const playerButton = document.getElementById('build-player');
        if (playerButton) {
            playerButton.click();
        } else {
            console.warn('未找到玩家工具按钮');
            // 默认选中第一个可用的工具按钮
            const firstToolButton = buildModeToolbar.querySelector('button');
            if (firstToolButton) {
                firstToolButton.click();
            }
        }
    }, 100);

    console.log("建造模式界面创建完成");
}

// 验证当前关卡是否有解
async function validateCurrentLevel() {
    console.log("开始验证当前关卡");

    // 首先验证关卡基础结构是否合法
    if (!validateBuiltLevel()) {
        console.log("关卡基础验证失败");
        // 验证失败已在validateBuiltLevel中显示错误信息
        return;
    }

    // 显示验证中状态
    const validationResultDiv = document.getElementById('validation-result');
    if (validationResultDiv) {
        validationResultDiv.textContent = getText('buildLevelValidating');
        validationResultDiv.style.display = 'block';
        validationResultDiv.style.backgroundColor = '#f39c12'; // 黄色，表示正在验证
        validationResultDiv.style.color = 'white';
    }

    try {
        console.log("创建求解器状态...");
        // 创建用于求解的State对象
        const solverState = await createSolverState();

        if (!solverState) {
            console.error('创建求解状态失败');
            showValidationResult(false, 0, '创建求解状态失败');
            return;
        }

        console.log("求解中...");
        // 验证是否有解，使用更大的迭代次数限制
        const solution = await solvePuzzleWithHigherLimits(solverState);

        if (solution && solution.length > 0) {
            // 关卡有解
            console.log(`关卡验证成功！找到解决方案，共${solution.length}步`);

            // 计算推箱子步数
            const boxPushes = solution.filter(step =>
                step.boxIndex !== undefined && step.boxIndex !== -1
            ).length;

            // 显示成功结果
            showValidationResult(true, boxPushes);
        } else {
            // 关卡无解或求解超时
            console.log("关卡无法求解");

            // 获取内存和迭代信息
            const memoryLimit = defaultSettings.maxNodesInMemory || 15000;
            const iterLimit = defaultSettings.maxSolverIterations || 10000;

            showValidationResult(false, 0,
                `求解器无法在限定资源内找到解决方案。复杂关卡可能需要多次尝试。`);
        }
    } catch (e) {
        console.error("验证关卡过程中出错:", e);
        showValidationResult(false, 0, e.message);
    }
}

/**
 * 使用更高的限制参数求解推箱子关卡
 * @param {State} state - 初始状态
 * @returns {Array} 解决步骤
 */
async function solvePuzzleWithHigherLimits(state) {
    try {
        // 导入求解器
        const { Solver } = await import('./js/Solver.js');

        // 创建求解器实例
        const solver = new Solver(state);

        // 使用设置中参数的更高倍数，确保能找到解决方案
        const baseIterations = defaultSettings.maxSolverIterations || 5000;
        const baseMemory = defaultSettings.maxNodesInMemory || 15000;

        solver.maxIterations = Math.max(baseIterations * 10, 50000); // 至少5万次迭代
        solver.maxNodesInMemory = Math.max(baseMemory * 6, 100000); // 至少10万内存节点

        console.log(`关卡验证求解，最大迭代次数: ${solver.maxIterations}, 最大内存节点数: ${solver.maxNodesInMemory}`);

        // 执行求解
        const result = solver.run();

        if (result === 1) {
            console.log('找到解决方案，步骤数:', solver.steplist.length - 1);
            return solver.steplist;
        } else if (result === -1) {
            console.error('关卡无解');
            return null;
        } else {
            // 检查是因为迭代次数还是内存节点数限制导致的停止
            let limitReason = '';
            if (solver.iterNum >= solver.maxIterations) {
                limitReason = `达到最大迭代次数${solver.maxIterations}`;
            } else {
                limitReason = `达到最大内存节点数${solver.maxNodesInMemory}`;
            }
            console.error(`求解超时，${limitReason}`);
            return null;
        }
    } catch (error) {
        console.error('求解过程出错:', error);
        return null;
    }
}

// 显示验证结果
function showValidationResult(isValid, minSteps = 0, errorMsg = null) {
    const validationResultDiv = document.getElementById('validation-result');
    if (!validationResultDiv) return;

    validationResultDiv.style.display = 'block';
    // 清空之前的内容
    validationResultDiv.innerHTML = '';

    if (isValid) {
        // 关卡有解
        validationResultDiv.textContent = getText('levelSolved', { minSteps });
        validationResultDiv.style.backgroundColor = '#27ae60'; // 绿色
        validationResultDiv.style.color = 'white';
    } else {
        // 关卡无解或验证出错
        const message = errorMsg ?
            `${getText('levelUnsolved')} (${errorMsg})` :
            getText('levelUnsolved');

        const messageElem = document.createElement('div');
        messageElem.textContent = message;
        validationResultDiv.appendChild(messageElem);

        // 添加重试提示
        const retryMsg = document.createElement('div');
        retryMsg.innerHTML = '提示：关卡可能有解，但求解器资源有限。您可以：<br>' +
            '1. 再次点击"验证关卡"按钮尝试<br>' +
            '2. 简化关卡设计<br>' +
            '3. 直接点击"确认保存并开始"尝试自己解决';
        retryMsg.style.fontSize = '12px';
        retryMsg.style.marginTop = '8px';
        retryMsg.style.fontWeight = 'normal';
        retryMsg.style.lineHeight = '1.5';

        validationResultDiv.appendChild(retryMsg);
        validationResultDiv.style.backgroundColor = '#e74c3c'; // 红色
        validationResultDiv.style.color = 'white';
    }
}

// 处理建造模式下的画布点击
function handleBuildModeClick(event) {
    if (!selectedTile) return;

    // 获取点击位置对应的格子坐标
    const rect = event.target.getBoundingClientRect();
    const scaleX = event.target.width / rect.width;
    const scaleY = event.target.height / rect.height;

    const x = Math.floor((event.clientX - rect.left) * scaleX / config.tileSize);
    const y = Math.floor((event.clientY - rect.top) * scaleY / config.tileSize);

    // 确保坐标在棋盘范围内
    if (x < 0 || x >= config.boardSize.width || y < 0 || y >= config.boardSize.height) return;

    // 根据选中的工具进行相应操作
    switch (selectedTile) {
        case 'player':
            // 移除之前的玩家位置
            gameState.playerPos = { x, y };

            // 确保该位置没有墙壁
            gameState.board[y][x] = 'floor';
            break;

        case 'wall':
            // 添加墙壁
            // 先检查该位置是否已有墙壁
            if (gameState.board[y][x] === 'wall') {
                // 如果已有墙壁，则移除
                gameState.board[y][x] = 'floor';
            } else {
                // 否则添加新墙壁
                gameState.board[y][x] = 'wall';

                // 确保该位置没有玩家
                if (gameState.playerPos.x === x && gameState.playerPos.y === y) {
                    gameState.playerPos = { x: -1, y: -1 };
                }

                // 移除该位置的箱子和目标点
                gameState.boxes = gameState.boxes.filter(box => !(box.x === x && box.y === y));
                gameState.targets = gameState.targets.filter(target => !(target.x === x && target.y === y));
            }
            break;

        case 'box':
            // 添加箱子
            // 先检查该位置是否已有箱子
            const existingBoxIndex = gameState.boxes.findIndex(box => box.x === x && box.y === y);

            if (existingBoxIndex !== -1) {
                // 如果已有箱子，则移除
                gameState.boxes.splice(existingBoxIndex, 1);
            } else {
                // 否则添加新箱子
                // 确保该位置没有墙壁
                if (gameState.board[y][x] === 'wall') {
                    gameState.board[y][x] = 'floor';
                }

                gameState.boxes.push({ x, y });
            }
            break;

        case 'target':
            // 添加目标点
            // 先检查该位置是否已有目标点
            const existingTargetIndex = gameState.targets.findIndex(target => target.x === x && target.y === y);

            if (existingTargetIndex !== -1) {
                // 如果已有目标点，则移除
                gameState.targets.splice(existingTargetIndex, 1);
            } else {
                // 否则添加新目标点
                // 确保该位置没有墙壁
                if (gameState.board[y][x] === 'wall') {
                    gameState.board[y][x] = 'floor';
                }

                gameState.targets.push({ x, y });
            }
            break;

        case 'floor':
            // 清除该位置的所有元素
            gameState.board[y][x] = 'floor';
            if (gameState.playerPos.x === x && gameState.playerPos.y === y) {
                gameState.playerPos = { x: -1, y: -1 };
            }
            gameState.boxes = gameState.boxes.filter(box => !(box.x === x && box.y === y));
            gameState.targets = gameState.targets.filter(target => !(target.x === x && target.y === y));
            break;
    }

    // 重新渲染游戏
    renderGame();
}

// 验证自定义关卡是否有效
function validateBuiltLevel() {
    // 检查是否有一个玩家
    if (gameState.playerPos.x === -1 || gameState.playerPos.y === -1) {
        showCustomAlert("请放置一个玩家角色。");
        return false;
    }

    // 检查是否至少有一个箱子和相同数量的目标点
    if (gameState.boxes.length === 0) {
        showCustomAlert("请至少放置一个箱子。");
        return false;
    }

    if (gameState.targets.length === 0) {
        showCustomAlert("请至少放置一个目标点。");
        return false;
    }

    if (gameState.boxes.length !== gameState.targets.length) {
        showCustomAlert(`箱子数量(${gameState.boxes.length})与目标点数量(${gameState.targets.length})不一致。`);
        return false;
    }

    // 检查是否有箱子被完全包围在墙壁中，这样的箱子无法移动
    const boxesWithIssues = [];

    for (const box of gameState.boxes) {
        let surroundedByWalls = true;

        // 检查四个方向
        const directions = [
            { dx: 0, dy: -1 }, // 上
            { dx: 1, dy: 0 },  // 右
            { dx: 0, dy: 1 },  // 下
            { dx: -1, dy: 0 }  // 左
        ];

        for (const dir of directions) {
            const nx = box.x + dir.dx;
            const ny = box.y + dir.dy;

            // 检查边界
            if (nx < 0 || ny < 0 || nx >= config.boardSize.width || ny >= config.boardSize.height) {
                continue;
            }

            // 如果有一个方向不是墙壁，那么箱子就不是被完全包围的
            if (gameState.board[ny][nx] !== 'wall') {
                surroundedByWalls = false;
                break;
            }
        }

        if (surroundedByWalls) {
            boxesWithIssues.push(`(${box.x},${box.y})`);
        }
    }

    if (boxesWithIssues.length > 0) {
        showCustomAlert(`以下位置的箱子被墙壁完全包围，无法移动: ${boxesWithIssues.join(', ')}`);
        return false;
    }

    // 检查是否有死角（两个相邻的墙角），箱子进入后无法移出
    // 简化版的检查，完整检查较为复杂

    return true;
}



// 尝试从本地存储加载关卡
function tryLoadFromLocalStorage() {
    try {
        console.log("尝试从本地存储加载关卡");

        // 尝试获取上次保存的关卡数据
        const savedLevelData = localStorage.getItem('lastSavedLevel') || localStorage.getItem('sokobanSavedLevel');

        if (!savedLevelData) {
            console.warn("未找到已保存的关卡数据");
            showCustomAlert(getText('noSavedLevel'));
            return false;
        }

        console.log("从本地存储找到关卡数据");

        try {
            // 解析JSON数据
            const levelData = JSON.parse(savedLevelData);

            // 加载关卡
            const success = loadLevelFromData(levelData);

            if (success) {
                // 显示成功消息
                showCustomAlert(getText('loadLevelSuccess') + ' (从本地存储)');
                return true;
            }
        } catch (parseError) {
            console.error("解析本地存储关卡数据失败:", parseError);
            showCustomAlert(getText('loadLevelFail') + " - " + parseError.message);
        }

        return false;
    } catch (e) {
        console.error("从本地存储加载关卡失败:", e);
        showCustomAlert(getText('loadLevelFail'));
        return false;
    }
}

// 计算特定类型瓦片的数量
function countTiles(tileType) {
    let count = 0;
    for (let y = 0; y < gameState.board.length; y++) {
        for (let x = 0; x < gameState.board[y].length; x++) {
            if (gameState.board[y][x] === tileType) {
                count++;
            }
        }
    }
    return count;
}

// 更新玩家创建关卡的信息
function updateBuildLevelInfo(minSteps, iterations, wallCount, boxCount) {
    // 更新AI信息区域
    updateAILevelInfo(minSteps, iterations, wallCount);

    // 获取AI信息元素并添加箱子数量信息
    const aiInfo = document.getElementById('ai-info');
    if (aiInfo) {
        // 添加箱子数量信息
        if (currentLanguage === 'zh') {
            aiInfo.textContent += `, 箱子数量: ${boxCount}`;
        } else {
            aiInfo.textContent += `, Box count: ${boxCount}`;
        }
    }

    console.log(`已更新自建关卡信息: 最少步数=${minSteps}, 迭代次数=${iterations}, 墙壁数量=${wallCount}, 箱子数量=${boxCount}`);
}

// 清空当前场景
function clearCurrentScene() {
    console.log("清空当前场景");

    // 初始化一个空的游戏板
    initializeBoard();

    // 清空箱子、目标点和玩家位置
    gameState.boxes = [];
    gameState.targets = [];
    gameState.playerPos = { x: -1, y: -1 }; // 初始时没有玩家

    // 重新渲染游戏
    renderGame();

    // 显示验证结果区域，提示已清空
    const validationResultDiv = document.getElementById('validation-result');
    if (validationResultDiv) {
        validationResultDiv.textContent = getText('sceneCleared');
        validationResultDiv.style.display = 'block';
        validationResultDiv.style.backgroundColor = '#9b59b6'; // 紫色
        validationResultDiv.style.color = 'white';

        // 几秒后自动隐藏提示
        setTimeout(() => {
            validationResultDiv.style.display = 'none';
        }, 3000);
    }

    console.log("场景已清空");
}

// 更新建造模式面板的文本
function updateBuildModeUI() {
    // 检查是否处于建造模式
    if (!buildMode) return;

    // 获取建造模式面板
    const buildModePanel = document.getElementById('build-mode-panel');
    if (!buildModePanel) return;

    // 更新标题
    const title = buildModePanel.querySelector('h2');
    if (title) {
        title.textContent = getText('buildLevelTitle');
    }

    // 更新说明文本
    const instructions = buildModePanel.querySelector('p');
    if (instructions) {
        instructions.textContent = getText('buildLevelInstructions');
    }

    // 更新左侧标题
    const toolsTitle = buildModePanel.querySelector('h3');
    if (toolsTitle) {
        toolsTitle.textContent = currentLanguage === 'zh' ? '工具选择' : 'Tool Selection';
    }

    // 更新右侧标题
    const settingsTitle = buildModePanel.querySelectorAll('h3')[1];
    if (settingsTitle) {
        settingsTitle.textContent = currentLanguage === 'zh' ? '关卡设置' : 'Level Settings';
    }

    // 更新工具按钮文本
    const playerBtn = document.getElementById('build-player');
    const wallBtn = document.getElementById('build-wall');
    const boxBtn = document.getElementById('build-box');
    const targetBtn = document.getElementById('build-target');
    const floorBtn = document.getElementById('build-floor');

    if (playerBtn) {
        const span = playerBtn.querySelector('span');
        const text = getText('buildLevelPlayer');
        if (span) {
            playerBtn.innerHTML = `<span style="margin-right:5px;">${span.innerHTML}</span> ${text}`;
        } else {
            playerBtn.textContent = text;
        }
    }

    if (wallBtn) {
        const span = wallBtn.querySelector('span');
        const text = getText('buildLevelWall');
        if (span) {
            wallBtn.innerHTML = `<span style="margin-right:5px;">${span.innerHTML}</span> ${text}`;
        } else {
            wallBtn.textContent = text;
        }
    }

    if (boxBtn) {
        const span = boxBtn.querySelector('span');
        const text = getText('buildLevelBox');
        if (span) {
            boxBtn.innerHTML = `<span style="margin-right:5px;">${span.innerHTML}</span> ${text}`;
        } else {
            boxBtn.textContent = text;
        }
    }

    if (targetBtn) {
        const span = targetBtn.querySelector('span');
        const text = getText('buildLevelTarget');
        if (span) {
            targetBtn.innerHTML = `<span style="margin-right:5px;">${span.innerHTML}</span> ${text}`;
        } else {
            targetBtn.textContent = text;
        }
    }

    if (floorBtn) {
        const span = floorBtn.querySelector('span');
        const text = getText('buildLevelFloor');
        if (span) {
            floorBtn.innerHTML = `<span style="margin-right:5px;">${span.innerHTML}</span> ${text}`;
        } else {
            floorBtn.textContent = text;
        }
    }

    // 更新清空场景按钮
    const clearSceneBtn = document.getElementById('clear-scene-btn');
    if (clearSceneBtn) {
        clearSceneBtn.textContent = getText('clearSceneBtn');
    }

    // 更新尺寸标签
    const sizeLabel = buildModePanel.querySelector('label');
    if (sizeLabel) {
        sizeLabel.textContent = getText('boardSize') + ': ';
    }

    // 更新取消和确认按钮
    const cancelBtn = document.getElementById('build-cancel-btn');
    const confirmBtn = document.getElementById('build-confirm-btn');

    if (cancelBtn) {
        cancelBtn.textContent = getText('buildLevelCancel');
    }

    if (confirmBtn) {
        confirmBtn.textContent = getText('buildLevelConfirm');
    }
}